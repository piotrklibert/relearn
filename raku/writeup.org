#+TITLE: Printing tables in terminal with Raku
#+OPTIONS: inline:t
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-bigblow.setup
#+HTML_HEAD: <style type="text/css"> pre { background-color: #232324 !important; color: white;  } .src-smalltalk, .src-text { color: white !important; } </style>

* Foreword
:PROPERTIES:
:CUSTOM_ID: foreword
:END:

*** Time to learn something new!
:PROPERTIES:
:CUSTOM_ID: foreword__time-to-learn-something-new!
:END:

It's been quite a long time since I last learned a new programming language that
was even a bit interesting. I learned [[https://www.lua.org/][Lua]], [[https://moonscript.org/][MoonScript]], and then [[https://haxe.org/][Haxe]] to script
my window manager, then came back to [[https://www.gnu.org/software/smalltalk/][Smalltalk]] trying to create a multi-player
shell in it, and more recently I learned [[https://www.rust-lang.org/][Rust]] for [[https://webassembly.org/][WebAssembly]] development. It's
been more than 3 months since then, so it's time to move on again!

This time I wanted a language that I could use for quick, often one-off, scripts
for command line. Instead of a traditional mixture of =sed=, =AWK=, =BASH=, and
=Python=, I wanted one language that could perform all their functions in a
day-to-day scripting.

One of the most important requirements for that language was that I don't know
it yet (I could compromise on that only if there were no such candidates). Other
than that, I wanted something *succint* and *expressive*, supporting creation of
*internal DSLs*. Finally, I wanted a language with features helpful in assuring
*correctness* of programs written in it.

*** Eliminations
:PROPERTIES:
:CUSTOM_ID: foreword__eliminations
:END:

After preliminary investigation and some research, out of [[https://klibert.pl/timeline.png][quite a few]] languages
that I know, plus some more that [[https://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/][came up]] when researching[fn:1] the topic, only
a few languages remained. These were:

- [[http://www.rebol.net/][REBOL]] or [[https://www.red-lang.org/][Red]]
- [[https://clojure.org/][Clojure]], or rather [[https://clojurescript.org/][ClojureScript]] on Node.js
- [[https://livescript.net/][LiveScript]][fn:2] on Node.js 
- [[https://racket-lang.org/][Racket]] on Chez Scheme
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html][Emacs Lisp]] with ~emacs --batch~
- [[https://www.scala-lang.org/][Scala]] on JVM
- [[https://raku.org/][Raku]] on [[https://moarvm.com/][MoarVM]]

Out of these, the only ones that I don't know at all were REBOL, Red, and Raku.

It's hard to say how actively developed REBOL is, and I don't quite trust its
development model. Red is an interesting proposition, but it's immature, and I
don't quite agree with the team's priorities. Raku seemed more actively
developed than REBOL and more mature than Red.

*TL;DR*: only *Raku* was left standing, with corpses of other contenders piled
up in a corner. Playing with *Raku* will be fun, will be fun, will be fun... for
a while.

# (I excluded some extreme cases, like Haskell, J, or FORTH)

# All worth considering, but most have things that made me pass on them. For
# example, I don't 100% trust the REBOL model of development, and Red is still a
# decade before half if its promises materialize. I know Scala already, but it's
# in a dangerous period right now - a Python-like phase-transition from 2.x to
# 3.x - and I'd rather wait that one out. Clojure on its own is a hard pass,
# because of the startup time. But ClojureScript runs on Node - worth considering,
# but I already know Clojure, so maybe another day. Racket is always, always in my
# heart[fn:4], but I've been playing with too many Lisps as of late anyway.

# LiveScript has a lot of syntactic sugar that's similar to Raku, Perl, and
# Haskell, plus it has access to NPM. Similarly, Emacs Lisp is surprisingly an
# extremely capable language - incredible amount of work went into both the
# implementation, stdlib, and libraries - there's more Elisp packages than Raku
# packages in their respective package repositiories. But, I know both Elisp and
# LS, use then constantly, which would make the whole thing much less interesting.

*** So what's up with this article?
:PROPERTIES:
:CUSTOM_ID: foreword__so-what's-up-with-this-article
:END:

Well, I decided to document my learning of Raku somehow. I thought of a simple
project that should be immediately understood by anyone, and started
implementing it in Raku, reading lots of docs in the process. 

Normally, the effect of this would be a some code in a module on my disk and
nothing else. But I thought that, with a bit of a commentary, that code could be
of help to others wanting to learn Raku. I decided to turn the module into a
Literate Programming[fn:3] document.

*Warning:* all of this is written purely *for science* (and fun)! The code is
not intended to be /idiomatic/, /fast/, or /fit for any purpose/ other than the
one expressly stated, that is: to highlight interesting linguistic features I
found in Raku.

*** So what are we going to build?
:PROPERTIES:
:CUSTOM_ID: foreword__so-what-are-we-going-to-build
:END:

It's very simple. Problem statement:

#+begin_quote
Write a function that will take a list of strings and will print the words in an
aligned table in the terminal. Make sure colored table elements are also
displayed properly.
#+end_quote

That's it. Here's the end result (the characters used to pad cells and columns
are obviously configurable): 

#+HTML: <img src="./img/end-result.png" width="60%" />

Some side-goals:

- showcase the *contracts-based* programming style in the vein of Racket, in
  Raku
- make an example of something useful that uses the module functionality

If you're curious about the examples, the two I have in mind are:

- REPL introspection/ease of use improvement; and
- standard, tabular JSON data printing 

That's it for introduction, let's move over to the code.


* Code
:PROPERTIES:
:CUSTOM_ID: code
:END:
** Overview
:PROPERTIES:
:CUSTOM_ID: code__overview
:END:

Raku source code is kept in files with =.raku= and =.rakumod= extensions[fn:4];
the former meant for scripts, the latter for... well, modules. We'll be creating
a bunch of modules and one script (in this section, there are some more files in
the following ones):

- =run.raku= - imports our modules and performs some tests
- =ShowTable.rakumod= - most of the functionality is here
- =Utils.rakumod= - a few general-purpose utils that stdlib lacks
- =Colors.rakumod= - helpers for handling colored text in tables

Let's start with the longest and most heavily commented file first:
=ShowTable.rakumod=, the heart of the library.

** ShowTable.rakumod
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod
:END:
*** Module preamble
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__module-preamble
:END:

#+begin_src raku -n :tangle ShowTable.rakumod
  use v6.d;
#+end_src

Each file starts with a declaration of the minimum version of the language spec
required to run this code. Apparently, the =v6= part will remain that way
forever - as a bitter reminder of a historically bad decision to call Raku Perl6
at first. So, instead the major releases are identified by the letter after dot.
(Version "d", which apparently has code name "Diwali"[fn:5], is current, and
replaced "c" for "Christmas" in 2018)

#+begin_src raku +n :tangle ShowTable.rakumod
  unit module ShowTable;
#+end_src

Modules can be written like this:

#+begin_src raku
  module M {
      # functions, classes, etc. here
  }
#+end_src

but if there's just one module in a file, the =unit= qualifier comes in handy -
it treats the rest of the file as a module body.

BTW: for some reason "unit" is never highlighted as a keyword on Github[fn:8] and
even on Raku's own page... Strange.

#+begin_src raku +n :tangle ShowTable.rakumod
  use Utils;
  use Colors :types;  
#+end_src

Once inside our module, we import two other modules. =use= statement loads them,
and then injects their exports into the current lexical scope, without warning
and with impunity. The module system in Raku gives /way too much power/ to the
module authors over what happens when their module is imported - it's especially
harmful because the defaults are bad. I'll say more about it when discussing
exports below.

*** Subsets - common, run-time checked, constraints 
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__subsets---common,-run-time-checked,-constraints
:END:

If you know Racket, then subsets are [[https://docs.racket-lang.org/reference/contracts.html][simply flat contracts]].

Otherwise, you can think of them like this: a =subset= is a *named* set of
*assertions* about the shape or structure some value can take. Those assertions
can be *attached to variables, parameters, and functions*. Syntactically,
=subsets= can be used everywhere a simple type can, but checking if a value
fullfils the assertions is done at run-time, so the range of what you can check
for is much wider than with static types (in non-dependently-typed language,
anyway).

Another way of thinking about it is that subsets are syntactic sugar for the
more commonly used pre-conditions. If a pre-condition pops up in multiple
places, as long as it concerns a single variable or parameter, it can be
extracted into a named =subset=. This might not make much sense now, but after
you see a few pre-conditions at work, it should become clearer.

# not like i had these all from the beginning...

*One note:* these contracts are traditionally stored either at the top or at the
bottom of a file, here - at the top. They were not written all at once, and they
were closer to a place of use for most of the development time. In the first
version of the code I used =Str= and =Int= everywhere, like a sane person would.
I then started refining the contracts, trying to make them as precise as
practically relevant, over a few rounds of refactoring.

*Another note*: All of the constrained subtypes below are checked dynamically,
at run-time. I honestly have no idea how expensive these are. I hope they get
inlined properly, at least. 

In any case, run-time impact of contracts like this is always an issue,
traditionally solved by disabling checking of assertions in release mode. I'm
not sure if it's possible to easily do this in Raku: in the worst case I'd have
to edit the definitions below manually to comment out all the =where= clauses,
effectively transforming =subset= into a C-like =typedef=.


#+begin_src raku +n :tangle ShowTable.rakumod
  subset Positive of Int where * > 0;            # same as { $_ > 0 }
  subset Character of Str where { .chars == 1 }; # same as { $_.chars == 1 }
                                                 # or as *.chars == 1
#+end_src

# NOTE: made a mistake, wrote .elem here instead of .chars, postcondition caught it!

The names of these should be descriptive enough. The part that would need an
explanation is probably just the one after =where=. What you put there has to be
a callable, and is executed every time the variable constrained with the given
=subset= is used.

About the "callable" part: it has to be a routine that accepts a single
parameter. Raku has quite a few ways of writing anonymous callables, here you
can see two: [[https://docs.raku.org/type/WhateverCode][WhateverCode]] and [[https://docs.raku.org/type/Block][Block]]. The first one forms a block whose single
argument is replaced for the star =*= in the enclosing expression. The other
forms a block with the first positional parameter assigned to a "topic
variable", called =$_=, inside the block (similar to how blocks in Groovy or
Kotlin use =it= as a default block argument name). 

Another bit of syntax: in a method call, if the object (or "invokant" in
Raku-speak) is missing, the method is called on the topic variable. Various
constructs set the topic variable, including =for=, =with=, and =given= keywords.


#+begin_src raku +n :tangle ShowTable.rakumod
  subset MaybeColoredStr where Str | Colored;
  subset ColumnSpec where Iterable | Int | Nil;
#+end_src

Ok, so you remember I told you that =where= needs to be passed a callable?
Actually, no, I lied. Well, simplified. The truth is you can put there anything
that you can use the =~~= "smart-matching" operator[fn:10] on. That operator
works mostly by calling a magic-method called =ACCEPTS= on RHS. Various "things"
implement that method, including - as you probably realized already - callables,
where smart-matching simply calls the routine with LHS operand as an argument.

So what you can put into =where= clause includes everything that works with
=~~=, which is basically anything. For simple values, smart-matching is
analogous to structural comparison (written as ===== normally), but for type
and role (interfaces, mixins) they perform an =.isa= or =.does= check on the LHS
value.

*TL;DR*: =MaybeColoredStr=, when used, will check whether a given value is a
=Str=, =Colored=, or any of their subclasses.

The last interesting bit of syntax, and an interesting concepts is "junctions".
Junctions are basically lazy conditions that aggregate a bunch of condition
subjects, and are responsible for applying a check to all junctions members and
combining results. You could do the same with collections, but the syntax of
junctions is much nices. Last example on junctions before moving on:

#+begin_src raku
  dd my $ored = (3 | 4 | 5);      # is the same as: (3, 4, 5).any
  # Junction $ored = any(3, 4, 5)
  dd (4 == $ored);
  # any(Bool::False, Bool::True, Bool::False)
  dd (4 == $ored).so;             # reduces to single value in boolen context
  # Bool::True
  dd my $anded = (3 & 4 & 5);     # is the same as: (3, 4, 5).all
  # Junction $anded = all(3, 4, 5)
  dd $anded ∈ 1..10;              # ∈ mean "is element of"
  # all(True, True, True)
  dd ($anded ∈ 1..10).so;         # again, reduces to a single value
  # Bool::True
#+end_src

Pay attention to the "is the same as" comments: you'll need them in the next
fragment!

#+begin_src raku +n :tangle ShowTable.rakumod
  subset StrList of Iterable where { .cache.all ~~ MaybeColoredStr };
  subset IntList of Iterable where { .cache.all ~~ Int };
  subset StrTable of Iterable where { .cache.all ~~ StrList };
#+end_src

These checks are *expensive*, and they may have unintended cosequences for some
of the =Iterable= sybtypes (eg. the lazy ones, hence the =.cache=[fn:9] call).
On the other hand, not having to worry about the shape of the data *at all*
within this module is too convenient to give up, and my use case does not
involve large input sizes.

#+begin_src raku +n :tangle ShowTable.rakumod
  enum JustifyType is export <None Left Right Center>;
#+end_src

There are some advantages to the use of enums... and then there's Raku which
eliminates almost all of them... 🙂 No exhaustiveness checking, no distinct
identity for cases, no parametrization, just a little nicer syntax
for a named subset of literal values. Basically, it's an =enum= you know and
love from C, not a discriminated union you know and love more for ML.

And BTW, see this?

#+begin_src raku
  enum JustifyType is export <None Left Right Center>;
  #                            👆 
#+end_src

I wasn't intending on having this as an option, but then discovered that my
first option has a value of 0, which is treated as false in boolean context -
same as =Nil=. That means I'd need to check for definitedness (a way to discern
=Nil= from other falsey values) when using =JustifyType= with optional
arguments! I should probably just explicitly assign values to enums, but adding
=None= that would be 0/False kind-of-sort-of makes sense in this case, too.

*** Helpers for padding strings and lists
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__helpers-for-padding-strings-and-lists
:END:

I have to wonder, didn't NPM and /left-pad/ fiasco[fn:6] teach us all that
having no padding function in a standard library is a bad thing? (Well, among
other things about contemporary programmers' culture, but that's for another
time.) Most languages took it to heart; some examples:

- Python has =str.ljust, str.rjust, and str.center=
- Elixir has =String.pad_leading, String.pad_trailing= (no centering though)
- Nim has =strutils.{alignRight, alignLeft, center}=
- Haxe has =StringTools.{rpad, lpad}=
- Ruby has =String.{center, ljust, rjust}=
- Smalltalk (ST/X) has =CharArray>>{#paddedTo:, #leftPaddedTo:, #centerPaddedTo:}=
- Groovy has ={.padLeft, .padRight, .center}= added to =java.lang.String=

and so on... yet here Raku makes me code this by hand? Even Scala has at least
=String.padTo=! Or maybe I'm supposed to install a package just for this? I'm
still not quite sure what kinds of packages are there. I'll search for one
later; for now, coding it here seems like a better idea, because it gives me a
chance to demonstrate some of the Raku's safety features.

#+begin_src raku +n :tangle ShowTable.rakumod
  #| Pads given string with a given character up to a limit. Can pad on both
  #| sides.
  sub str-justify(
      MaybeColoredStr $s,
      Positive $limit,
      JustifyType $type,
      Character $pad = " ",
      --> Str(MaybeColoredStr)
  ) is export(:tests) {
      PRE $s.chars <= $limit;
      POST $_✔{ .no-color.chars == $limit } # NOTE: caught the problem with Character

      my $diff := $limit - $s.chars;
      given $type {
          when Left  { $s ~ ($pad x $diff); }
          when Right { ($pad x $diff) ~ $s; }
          when * { warn "Type {$type} not implemented yet!"; $s } # a bug here would be caught by the postcondition, too
      }
  }
#+end_src

*TODO*: =our= and =is export= explanation

*TODO*: first pre- and post-conditions

*TODO*: coercible types

# BTW: I think the module systems gives WAY too much to the module author. It's
# a module's user that should decide which identifiers they wish to have
# injected into often top-level module scope.

#+begin_src raku +n :tangle ShowTable.rakumod
  sub list-justify(
      Iterable $row,
      Positive $cols,
      Any :$fill = "",
      JustifyType :justify(:$type) = Left,
      --> List
  ) is export(:tests) {
      PRE $row.elems <= $cols; # TODO: description/extended name for the contract, { "jgvjv"; ...} or maybe  #= ?
      POST $_✔{ .elems == $cols };  

      return $row if .elems == $cols;
      my $diff := $cols - $row.elems;
      my $fill-list := (1..$diff).map:{ my $ = $fill }; # any other way?
      given $type {
          when Left  { $row ⊕ $fill-list }
          when Right { $fill-list ⊕ $row }
          when * { warn "Type {$type} not implemented yet!"; $row  }
      }
  }
#+end_src

The two routines look very similar, but I'm not convinced DRYing them would be a
good idea. The =list-justify= is more general, and we could reduce =str-justify=
to a simple call to =list-justify=:

#+begin_src raku
  list-justify($s.comb, $limit, $pad).join;
#+end_src

But handling colored text would still need to be done somewhere, and I imagine
using Str-specific functions will be faster than converting back and forth
between Str and List. We could make both justify functions into a single
=multi=, but I don't think it would be any better then currently. Or would it?

To abstract over the kind of a thing we're padding/justifying further we would
need to take a bunch of functions/operators, namely for: getting length of the
thing, multiplying (repeating) the thing, and concatenating two things. It would
be ={.chars}=, =&infix:<~>=, =&infix:<x>=, respectively, for strings. It can be
done, but again, I don't see the reason to. 

Also, first-class functions, especially partially applied ones, are really bad
for performance on MoarVM. As you can read on the [[https://moarvm.com/roadmap.html][Roadmap page]], work on
optimizing this is ongoing:

#+begin_quote
Better optimization around closures

Today's optimizer does a poor job of, and has an inability to inline, first
class functions and closures. Recent work has started to collect the data needed
to do better; optimizations to exploit it are still to come.
#+end_quote

*** Formatting a single cell
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__formatting-a-single-cell
:END:

#+begin_src raku +n :tangle ShowTable.rakumod
  #| Make sure the returned string has exactly $limit characters, clipping or
  #| padding as needed.
  our sub format-cell(
      MaybeColoredStr $text,
      Positive $cell-width,
      JustifyType :justify(:$cell-justify-type) = Left,
      Character :$cell-padding = " ",
      --> Str(MaybeColoredStr)
  ) {
      POST $_✔{ .no-color.chars == $cell-width };

      my Int $char-num := $text.chars;
      if $char-num > $cell-width {
          $text.substr(0, $cell-width - 1) ~ "…";
      }
      elsif $char-num < $cell-width && ?$cell-justify-type { 
          str-justify($text, $cell-width, $cell-justify-type, $cell-padding);
      }
      else {
          $text;
      }
  }
#+end_src

"Some people would have paused here and started making jokes about how Raku
can't have a "normal else if"... Whoever you are, please, don't be one of
people like *that*...""

*** Formatting the whole table
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__formatting-the-whole-table
:END:

In this routine, we make sure we're dealing with data of one shape only: a list
of rows of equal length, with each row being a list of strings. 

This assumption is expressed succintly and enforced by simply mentioning
=StrTable= in a type position. This assumption is costly to enforce, but frees
this routine from the need to handle most edge cases. 

There are two things that the =StrTable= contract doesn't enforce, so we check
for them in the first precondition. The =$table= has to be non-empty, and
lengths of each row have to be the same. The latter condition is important,
because it lets us rotate the table with =[Z]= meta-operator (see below) without
worrying about losing elements.


#+begin_src raku +n :tangle ShowTable.rakumod
  #| Create a multi-line string with values from $table aligned into columns.
  #| Passed $table cannot be empty.
  our sub format-table(
      StrTable $table is copy,
      Str :$col-separator = " ",
      Positive :$col-separator-width = 5,
      ColumnSpec :w(:chars(:$col-widths)) = Nil,
      Character :$cell-padding = " ",
      JustifyType :justify(:$cell-justify-type) = Left,
      --> Str
  ) is export {
      PRE $table.elems > 0 && [==] $table».elems; # NOTE
      PRE ($col-widths ~~ Iterable)⁈{ $col-widths.elems == $table[0].elems };

      my Str $fill := $col-separator x $col-separator-width;
      my @table = @$table;
      my $cols = [Z] @table;

      for get-col-widths($col-widths, $cols).kv -> $col, $max {
          $cols[$col].=map:{ format-cell($_, $max, :$cell-padding)  }
      }
      # for @table { .join($fill).comb.raku.say }
      join "\n", (.join($fill) for @table);
  }

  our sub show-table(|args) is export {
      put format-table(|args);
  }
#+end_src

In some Lisps, there's a map-list/apply-map-list idiom[fn:7], which forms a
=zip= function. Raku has both =zip= function and a zip /operator/, =Z=; it has
also the =reduce= (often called =fold= or =fold-left=) function and
/meta-operator/ too, so the apply-map-list is written as essentially reduce-zip,
but with shorthand syntax: =[Z] list-of-lists=. It's a simple way of rotating
the table, from list of rows to a list of columns and vice versa.


*** Helpers for interpreting column widths argument
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__helpers-for-interpreting-column-widths-argument
:END:

TODO: first multi-method

#+begin_src raku +n :tangle ShowTable.rakumod
  multi get-col-widths(Int $width, @cols --> IntList) { $width xx @cols.elems }
  multi get-col-widths(Iterable $widths, @cols --> IntList) { $widths }
  multi get-col-widths($ where ?*.not, @cols --> IntList) { samewith(@cols) }

  multi get-col-widths(@cols where { .all ~~ StrList  } --> IntList) {
      POST $_✔{ .elems == @cols.elems };
      my @widths[@cols.elems];
      @widths[$_] = @cols[$_]».chars.max for @widths.keys;
      @widths
  }
#+end_src

*** Converting lists to tables - the user-facing interface of the module
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__converting-lists-to-tables---the-user-facing-interface-of-the-module
:END:

#+begin_src raku +n :tangle ShowTable.rakumod
  use Terminal::Width; # TODO: be smarter about cols number/width if not specified

  our sub to-table(StrList $seq, Int :$cols = 5 --> StrTable) is export {
      my $table := $seq.batch($cols)».Array.Array;
      $table.tail.=&list-justify($cols);
      $table
  }

  sub make-lorem-table(Int :r(:$rows), Int :$cols, Int :$max = 9 --> StrTable) is export(:tests) {
      to-table :$cols, (Utils::lorem-word($max) xx ($rows × $cols))
  }

  our sub show-list-in-table(
      StrList $seq, :$cols = 6, :$row-padding = " ", *%kwargs
  ) is export {
      $seq ==> to-table(:$cols) ==> show-table(|%kwargs);
  }
#+end_src

** Utils.rakumod
:PROPERTIES:
:CUSTOM_ID: code__utils.rakumod
:END:

#+begin_src raku :tangle Utils.rakumod
  use v6.d;

  unit module Utils;

  sub show-section-sep() is export { print "\n" ~ "=" x 10 ~ "\n" x 2; }
  sub show-subsection-sep() is export { print "\n" ~ "-" x 10 ~ "\n\n"; }

  multi sub show-section($enabled, &block) { samewith(&block) if $enabled; }
  multi sub show-section(&block) is export {
      show-section-sep;
      block();
      show-section-sep;
  }

  my @lorem-chars = [ |('a'..'z'), |('A'..'Z'), |('0'..'9') ];

  our sub lorem-word(Int $max = 9, Int $min = 3) is export {
      my $span = $min .. $max;
      @lorem-chars.roll($span.pick).join("")
  }


  our sub bench(Int $rep, &block) {
      my $times = do for ^$rep {
          block();
          now - ENTER now;
      }
      my ($fst, *$rest) = $times;
      say "Calls: $rep / ", $fst, " / ", do .sum / .elems with $rest;
  }


  our sub defined-and(Mu $x, &block) is export {
      return True unless $x.defined;
      block($x);
  }

  multi sub infix:<✔>(Mu $x, &block) is export {
      return True unless $x.defined;
      block($x);
  }

  multi sub infix:<⁈>(Mu $x, &block) is export {
      return True unless $x.so;
      block($x);
  }


  # https://github.com/ajs/perl6-Operator-Listcat/blob/master/lib/Operator/Listcat.pm6
  multi sub infix:<listcat>(@a, @b) is equiv(&infix:<~>) is export { |@a, |@b }
  multi sub infix:<⊕>(Iterable $a, Iterable $b) is looser(&infix:<xx>) is export {
      |$a, |$b
  }


  our sub join-paths($base, $other --> IO::Path) is export { "$base/$other".IO }

  our sub list-dir($init where Str | IO::Path --> Seq) is export {
      my IO::Path @subdirs = [$init.IO.absolute.IO];
      gather while @subdirs {
          my $cur = @subdirs.shift(); # say $cur;
          my $seq := $cur.dir.cache;
          my ($, $dirs, $files) =
              take ($cur, $seq.grep(*.d)».basename, $seq.grep(*.d.not)».basename);
          my &absolutize := { join-paths($cur, $_) }
          @subdirs.prepend: $dirs».&absolutize;
      }
  }

#+end_src

** Colors.rakumod
:PROPERTIES:
:CUSTOM_ID: code__colors.rakumod
:END:

#+begin_src raku :tangle Colors.rakumod
  use v6.d;

  use MONKEY; # 🙈

  unit module Colors;

  use Terminal::ANSIColor;


  our class Colored is export(:types) {
      has Str $.style;
      has Str $.string handles ("chars");

      method new($str, $style) {
          self.bless(style => $style, string => $str)
      }
      method substr(::?CLASS:D: |args) {
          $!string.=substr(|args);
          self.Str;
      }

      method in-color(Str $!style) {}

      method no-color() {
          $!string
      }
    
      method Str() { $!string.&colored($!style) }
  }


  augment class Str {
      method in-color(Str:D : Str $c) {
          Colored.new(self, $c)
      }

      method no-color(Str:D:) {
          colorstrip(self)
      }
  }
#+end_src

* Examples of use
:PROPERTIES:
:CUSTOM_ID: examples-of-use
:END:

** Meta.rakumod
:PROPERTIES:
:CUSTOM_ID: examples-of-use__meta.rakumod
:END:

#+begin_src raku :tangle Meta.rakumod
  use v6.d;

  unit module Meta;

  use Terminal::ANSIColor;

  use Utils;
  use ShowTable;


  my $package-names = (
      "MY", "OUR", "CORE", "GLOBAL", "PROCESS", "CALLER", "CALLERS",
      "DYNAMIC", "OUTER", "OUTERS", "LEXICAL", "UNIT", "SETTING", "PARENT",
      "CLIENT"
  );

  # change my -> our to make all the functions available at once when testing
  module Priv {
      sub all-caps(Str $s --> Bool()) is export {
          $s.match: / ^(<upper>|<[-&$@_%!]>)+$ /;
      }

      sub show-class-header(Mu \obj) is export {
          say (
              "Class",
              colored(obj.^name, "green"),
              "is:",
              colored(obj.^mro.raku, "yellow"),
              "does:",
              colored((try obj.^roles.raku) || "<ERROR>", "bold")
          ).join(' ');
      }

      sub natural-ordering(Str $a, Str $b) is export {
          my ($caps-a, $caps-b) = (all-caps($a), all-caps($b));
          # dd $caps-a, $caps-b, $a, $b;
          my Order $ret = do {
              when $caps-a  && $caps-b  { $a cmp $b }
              when $caps-a  && !$caps-b { Less }
              when !$caps-a && $caps-b  { More }
              default                   { $a cmp $b }
          }
          # dd $ret;
          $ret
      }

      sub sort-by-name(Iterable $seq) is export {
          $seq.sort({ natural-ordering($^a.name, $^b.name) })
      }


      sub classify-symbols($seq) is export {
          $seq.classify: {
              when all-caps(.name) { 'caps' }
              when .name.match(/^<upper>/) { 'upper' }
              default { 'lower' }
          }
      }
  }

  import Priv;


  # ==============================================================================


  our sub meths(Mu \obj) is export {
      show-section-sep;
      show-class-header(obj);
      print "\n";

      my $rows = sort-by-name(obj.^methods.unique(:as(*.name))).map: {
          (colored(.name, "yellow"), .signature.raku, (try "{.file} : {.line}") || "<BUILT-IN>")
      };
      show-table($rows, :widths(15, 40, 40));
  }


  our sub doc($query, :l(:$lines) = 15) is export {
      my $res = qqx[ rakudoc '$query' ];
      if $res {
          say $res.lines[^$lines].join("\n")
      };
      "";
  }


  our sub cls(Mu \obj) is export {
      my $m = obj.^methods.unique(:as(*.name));
      my %m = classify-symbols($m);
      show-section-sep;
      show-class-header(obj);
      for <caps upper lower> {
          FIRST show-subsection-sep;
          sort-by-name(%m{$_})>>.name ==> show-list-in-table(:5cols) if %m{$_}:exists;
          show-subsection-sep;
      }
  }


  our sub ns($pkg) is export {
      # EXPORT::ALL::.keys
      my $fuck = 3;
      say $pkg.^name;
      # say ::("CALLER")::EXPORT::ALL::.keys;
      # $package-names.map({ "- " ~ (try { $_ ~ " " ~ ::("$_")::.keys.raku } || $_ )})>>.say;
  }

#+end_src

** pkgs.raku
:PROPERTIES:
:CUSTOM_ID: examples-of-use__pkgs.raku
:END:

#+begin_src raku :tangle pkgs.raku
  use v6.d;

  use JSON::Fast;

  use Colors;
  use ShowTable;
  use Utils;


  sub dt(Str $s --> Str) {
      with $s.DateTime {
          (.year, "-", .month.fmt('%02d'), "-", .day.fmt('%02d') ).join
      }
  }


  show-section 1, {
      my constant $fields := <name updated eco likes desc>;
      my constant $widths := [25,  10,     5,  3,    60];

      my @table = [];

      for "raku.pkgs".IO.lines -> $line {
          my $rows := $line.&from-json()>>.{ $fields };
          next unless $rows;
          my $cols := [Z] $rows;
          $cols[1].=map(&dt);     # Why is it working? What made $cols mutable?
          $rows := [Z] $cols;
          @table.append($rows);
      }
      @table.=squish(as => { .[0].lc });
      @table.=grep({ (.[0] | .[4]) ~~ rx:i/term/ });
      dd @table;
      show-table(@table, :col-widths($widths));
  }

#+end_src

* Other scripts
:PROPERTIES:
:CUSTOM_ID: other-scripts
:END:

Re-run a command if one of the watched files changes.

#+begin_src raku -n
  use v6.d;

  use Utils;
  use Colors;
  use ShowTable;

  constant Change = IO::Notification::Change;

  constant $command = "raku -Iraku raku/run.raku";


  sub re-run(Change $change) {
      my $path := $change.path;
      put "$path changed, running command:\n\t$command";
      my $status = shell($command).exitcode;
      my $color = $status ?? "red" !! "green";
      put "\n==========\n".indent(4).in-color($color);
      my $elapsed = now - ENTER now;
      put "Elapsed: $elapsed".indent(4).in-color($color);
      if $status == 0 {  qqx[ noti -m "$elapsed" -t "OK" ];    }
      else            {  qqx[ noti -m "$elapsed" -t "ERROR" ]; }
  }

  sub MAIN(Str $base) {
      my @files = dir($base).grep(/ '.raku'('mod')? $/).grep(none /watch/);
      say "Watching: "; @files».absolute.map(*.indent(4).say); say "";
      loop {
          my $supply = @files».watch.reduce({ $^a.merge($^b) });
          react {
              whenever $supply { re-run($_); done }
              # ie. either got Ctrl+C or this file changed
              whenever signal(SIGINT) | $?FILE.IO.watch { exit }
          }
          $supply = Nil;
      }
  }
#+end_src

* COMMENT ...
:PROPERTIES:
:CUSTOM_ID: ...
:END:

** fragments
:PROPERTIES:
:CUSTOM_ID: ...__fragments
:END:

# my constant Change = IO::Notification::Change;
# apparently, selective import is something that needs to be delegated to the
# ecosystem. There are some modules available, but for the simple case of
# shortening package-qualified names this construct suffices. BTW, the defaults
# for the module system are really bad in Raku. Well, better than Ruby, but
# still.


interested in the [[https://raku.org][Raku]] programming language. I even have a proper use-case this
time! Put simply: I want a shell-script replacement that is much safer to use
than BASH, but also more succint than Python. Another thing: I'd prefer a
general-purpose language, thank you for the suggestion, but no Elvish, Murex,
Oil, etc. Moving on:


So it started from the REPL. You see, you can check what methods has any given
object if you invoke a metaclass method called ~methods~. This is the same
approach as in Smalltalk/X:

#+begin_src smalltalk
  2 class getMethodDictionary keys.
  "OrderedCollection(#'*' #'+' #'-' #'/' #'//' #'\\' #abs #negated #quo: #bitAnd: #bitClear: #bitCount #bitInvert ....etc)"
#+end_src

in Raku this is written:

#+begin_src raku
  2.^methods
#+end_src

I mean, something about ~^~ character and "higher level", meta-programming? It's
just basic introspection though... 

In any case, the problem is in how the methods returned are represented, and
displayed. By default it looks like this:

#+begin_src text
  (new Capture Int sign Num Rat FatRat abs Bridge sqrt base polymod expmod is-prime floor ceiling round lsb msb narrow Range conj rand sin asin cos acos tan atan atan2 sec asec cosec acosec cotan acotan sinh asinh cosh acosh tanh atanh sech asech cosech acosech cotanh acotanh unpolar cis Complex log exp truncate isNaN log2 log10 roots succ pred WHICH ACCEPTS raku Bool Str Real Numeric gist DUMP BUILDALL chr unimatch uniname uniprop unival)
#+end_src

and, coupled with acute lack of screen real-estate, would be presented like
this:


Unnecessary addendum: you know when was the last time I've seen a REPL this
pretty? When working with FORTH. Really:


Hopefuly your shell would have wrapped the line for you, but that doesn't help
with readability much. It's possible to print each method in its own line
easily, but then there's too much space wasted, and you have to scroll to see
the beginning of the list, which is also less convenient then it could be.

So, to make the introspection a little more helpful, and for science of course!,
I decided to write a module for printing tables in a terminal. There are some
similar packages on https://raku.land, but neither one is exactly what I want,
and anyway, at that point I didn't think such a thing would be package-worthy on
its own. 



* Footnotes
:PROPERTIES:
:CUSTOM_ID: footnotes
:END:

[fn:10] [[https://docs.raku.org/routine/~~]]

[fn:9] https://docs.raku.org/routine/cache#(Any)_method_cache 

[fn:8] TODO: link 

[fn:1] Though methodology there is a bit questionable, at best. Plus, it's from
2013, and many languages didn't make it onto a list, and there are multiple
languages that faded into (even more) obscurity since then.

[fn:2] CoffeeScript was in top 5 languages in the study, and LS is even more
succint than Coffee.

[fn:3] http://literateprogramming.com/ and
https://en.wikipedia.org/wiki/Literate_programming

[fn:4] I think these are now recommended, there seem to be a few other
extensions, either used for specific things like tests (with =.t=), or
deprecated ones based on previous name of the language, eg. =.p6=.

[fn:5] Annual festival of light in Hinduism, happening for a few days in October
and November... apparently.

[fn:6] If you need refresher - I needed - here's the first googled article:
https://www.davidhaney.io/npm-left-pad-have-we-forgotten-how-to-program/

[fn:7] In Racket: =(apply map list '((a b) (c d))) ;=> '((a c) (b d))=



# Local Variables:                                                 #
# eval: (add-hook 'after-save-hook 'org-html-export-to-html nil t) #
# eval: (add-hook 'after-save-hook 'org-babel-tangle nil t)        #
# End:                                                             #
