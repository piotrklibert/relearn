#+TITLE: Printing tables in terminal with Raku
#+OPTIONS: inline:t toc:3 H:5 |:t
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/bigblow.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/hideshow.css"/>

#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>

#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
# #+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
# #+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <style type="text/css"> pre { background-color: #232324 !important; color: white;  } .src-smalltalk, .src-text { color: white !important; } </style>

* Foreword
:PROPERTIES:
:CUSTOM_ID: foreword
:END:

** Time to learn something new!
:PROPERTIES:
:CUSTOM_ID: foreword__time-to-learn-something-new!
:END:

I've been learning new languages for a decade and a half. At first, learning one
language took years. Further down the road, though, I noticed that time
shrinking by orders of magnitude. Thanks to that, I can learn a few new
languages every year, as I continue to treat programming language research as a
hobby.

In the past year and a half, I learned [[https://www.lua.org/][Lua]], [[https://moonscript.org/][MoonScript]], and later [[https://haxe.org/][Haxe]] - to
script my window manager, Awesome[fn:20]. Next, I came back to [[https://www.gnu.org/software/smalltalk/][Smalltalk]], trying
to create CLI environment working as *a multi-player shell* (that effort
stagnated due to limitations of the chosen platform). Afterward, I learned [[https://www.rust-lang.org/][Rust]]
(with a bit of Go and a refresher for C++ mixed in) for [[https://webassembly.org/][WebAssembly]] development.

A few months have already passed since then, so... It's time to move on again!
(Update: I'm getting back to Smalltalk development - I think of reviving my
shell project by re-targeting it for Visual Works... That's for later, though.)

Choosing the subsequent language to learn is still hard, even for me. There are
so many languages out there! However, this time, I had a rough idea of what I
wanted to learn. I wanted a language that I could use for quick, often one-off,
scripts for the command line. Instead of a traditional mixture of =sed=, =AWK=,
and =BASH=, and to get away from Python (for more complex scripts), I wanted one
language that would perform all their functions in day-to-day scripting.

Other requirements included: that it's a language I don't know yet (I could
compromise on that /only/ if there were no other candidates); that it's
*succinct* and *expressive*; that it supports the creation of *internal
DSLs*. Finally, I wanted a language with features helpful in assuring the
*correctness* of programs written in it.

*** Eliminations
:PROPERTIES:
:CUSTOM_ID: foreword__time-to-learn-something-new!__eliminations
:END:

After preliminary investigation and some research, out of [[https://klibert.pl/timeline.png][quite a few]] languages
that I know, plus some more that [[https://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/][came up]] when researching[fn:1] the topic, only
a few languages remained. These were:

- [[http://www.rebol.net/][REBOL]] or [[https://www.red-lang.org/][Red]]
- [[https://clojure.org/][Clojure]], or rather [[https://clojurescript.org/][ClojureScript]] on Node.js
- [[https://livescript.net/][LiveScript]][fn:2] on Node.js 
- [[https://racket-lang.org/][Racket]] on Chez Scheme
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html][Emacs Lisp]] with ~emacs --batch~
- [[https://www.scala-lang.org/][Scala]] on JVM
- [[https://raku.org/][Raku]] on [[https://moarvm.com/][MoarVM]]

Out of these, the only ones that I don't know at all were REBOL, Red, and Raku.

It's hard to say how actively developed REBOL is, and I don't quite trust its
development model. Red is an interesting proposition, but it's immature, and I
don't quite agree with the team's priorities. Raku seemed more actively
developed than REBOL and more mature than Red.

*TL;DR*: only *Raku* was left standing, with corpses of other contenders piled
up in a corner. Tonight with *Raku* will be fun, will be fun, will be fun! (For
a while.)

# (I excluded some extreme cases, like Haskell, J, or FORTH)

# All worth considering, but most have things that made me pass on them. For
# example, I don't 100% trust the REBOL model of development, and Red is still a
# decade before half if its promises materialize. I know Scala already, but it's
# in a dangerous period right now - a Python-like phase-transition from 2.x to
# 3.x - and I'd rather wait that one out. Clojure on its own is a hard pass,
# because of the startup time. But ClojureScript runs on Node - worth considering,
# but I already know Clojure, so maybe another day. Racket is always, always in my
# heart[fn:4], but I've been playing with too many Lisps as of late anyway.

# LiveScript has a lot of syntactic sugar that's similar to Raku, Perl, and
# Haskell, plus it has access to NPM. Similarly, Emacs Lisp is surprisingly an
# extremely capable language - incredible amount of work went into both the
# implementation, stdlib, and libraries - there's more Elisp packages than Raku
# packages in their respective package repositiories. But, I know both Elisp and
# LS, use then constantly, which would make the whole thing much less interesting.

** What's up with this article?
:PROPERTIES:
:CUSTOM_ID: foreword__what's-up-with-this-article
:END:

*** Motivation
:PROPERTIES:
:CUSTOM_ID: foreword__what's-up-with-this-article__motivation
:END:

Well, I decided to document my learning of Raku somehow. 

The usual process I take with most new languages is a bit complex; it's split
into a few stages/phases, and one of them is supposed to end with Â±500 lines of
working code. That code is supposed to use minimal external dependencies - just
base language and its stdlib. This happens to be where I am today with Raku (for
reference: May 5th, 2022).

Getting to this point, in Raku's case, wasn't very hard, but what made it more
complicated was complete lack of materials of a certain type: ones that would
give an overview of the more interesting or advanced features of the language. I
found three types of resources:

1. "Whirlwind tour"-style, very short, with very little (if any) explanation.
2. Bite-sized blog posts on what to do in a certain situation.
3. Long and detailed reference manuals in the official docs.

What I felt was sorely missing was basically an aggregation of pt. 2. posts,
with some additional explanation and links to the docs where needed.

I thought that I might as well contribute something to improve the situation.
This article is an attempt at that. At the same time, I'm trying to give
feedback to the community on how its learning materials fare from the
perspective of a beginner. I'm cheating, of course: I am by no means a beginner
in *learning* programming languages, but in this case I think that would be an
advantage

*** The article formula
:PROPERTIES:
:CUSTOM_ID: foreword__what's-up-with-this-article__the-article-formula
:END:

To serve both purposes - to help future Raku beginners and to help community
improve learning materials - I thought it would be best to start with the code I
wrote during learning. This way I can both explain the reasons for using a
feature (would be harder with someone else's code) and describe my experience of
learning about it.

In the end, I decided to turn the code I had - a simple package for printing
text in columns - into a *Literate Programming*[fn:3] document. LP is a way of
writing code that interleaves rich documentation with actual code. You might
have encountered Jupyter Notebooks before - they implement a variation of the
same idea. Normally, writing in LP style requires quite a lot of effort, but
Emacs, and more specifically Org Mode[fn:4] and Babel[fn:5], make it trivial.
You can read the document in its intended form either on Github, or on my blog:

- [[https://github.com/piotrklibert/relearn/blob/master/raku/writeup.org][version in GitHub]]
- [[https://klibert.pl/statics/raku/writeup.html][self-hosted article]] (recommended)

Be warned that GitHub does not correctly render all the styles, so if you choose
to read there, some elements will look worse than in the standalone version.

*** Disclaimer and fair warning
:PROPERTIES:
:CUSTOM_ID: foreword__what's-up-with-this-article__disclaimer-and-fair-warning
:END:

I read a bunch of docs and wrote some trivial code. That's the extent of my
knowledge. Don't expect the code to be idiomatic - if it happens to be, that's
by accident or mistake. I provide my explanations on an "as is" basis, without
any warranty whatsoever. I'm writing from a perspective that allows me to be
wrong, a lot, without consequences, so I probably *will* be wrong. I do accept
PRs with corrections, though...

At this point, after this article, I should be advancing to the next stage. To
show you that I *am* paying attention and plan to dig deeper, here's a list of
things that I did not yet have time to investigate:

- how any of the other similar packages[fn:6] is written
- what general-purpose, quality-of-life improving utilities are available
- the plans for the future and what is currently being implemented in Rakudo
- the details of how the work is split between  Rakudo, NQP, and MoarVM 
- what is it about RakuAST and if it's possible the macros become usable
- what is written in The Official Raku Test Suite (ROAST)
- what is happening in Raku's blog-o-sphere, including archives & current threads
- who the main contributors are, what vision do they try to follow
- how good is [[https://commaide.com/][Comma IDE]], a Raku-dedicated environment (the one and only)
- how various constructs are implemented, including junctions and subsets
- details of the meta-model - metaclasses, method objects, traits (but see note)
- what is the performance in various conditions - I only have a bit of anecdata
  (ie. sample size == 1)
- why does =[Z]= (and even simply repeated =Z= applications in the same expression) work
  - Update: apparently, it's about associativity of both functions and
    operators. See [[https://docs.raku.org/language/operators#Operator_associativity][appropriate ]][[https://docs.raku.org/language/functions#Associativity][sections]] of the docs.
- how to make the colored strings work in a more idiomatic way (without =augment=)
  - it was suggested to me that [[https://docs.raku.org/type/Signature#index-entry-Coercion_type][coercion types]] described in more detail in these
    [[https://vrurg.github.io/2020/11/16/Report-On-New-Coercions][two]] [[https://vrurg.github.io/2020/11/30/Report-On-New-Coercions-Part-2][articles]] could be used in a better way.
- what's up with =ForeignCode= objects in meta-classes of meta-classes

# TODO: make into an example
# #+begin_src raku
#   1.HOW.HOW.^methods.map(-> $a { say "{$a.key}\n{$a.value}" }, :kv)[^5];
#   1.HOW.HOW.^methods.sort(*.key)[^10].map(*.say);
#   # > 1.HOW
#   # Perl6::Metamodel::ClassHOW.new
#   # > 1.HOW.HOW
#   # (low-level object `NQPClassHOW`)
# #+end_src

- and *many*, many, many, maaaany more

Moreover, I didn't track the history of Raku, nor its prehistory (ie. Perl 5).
Everything I write is based on roughly _4 weeks of afternoon sessions_ with
official docs and Google, as they were in _April - May 2022_.


** The example - aligning strings in columns
:PROPERTIES:
:CUSTOM_ID: foreword__the-example---aligning-strings-in-columns
:END:

The module we're going to write is a simple utility for printing tables - that
is, a bunch of strings aligned into columns - in a terminal. The module should
be able to also handle colored (or otherwise styled) text, where some parts of
the string are control sequences that are not displayed (and hence need to be
ignored when computing the width of a string).

The module should be somewhat configurable - the user should be able to choose
padding characters, columns width, alignment type - but it's not going to be a
full TUI framework. It's just an example. If you want to add interactivity,
multiline cells, borders, etc. - there are already much better packages[fn:6]
available!

That's it. Here's the end result (the characters used to pad cells and columns
are obviously configurable): 

#+HTML: <img src="./img/end-result.png" width="60%" />

Here it's used to interrogate an object in the REPL:

#+HTML: <img src="./img/meta.png" width="60%" />

And here's an example of use for displaying tabular data from JSON:

#+HTML: <img src="./img/pkgs.png" width="60%" />

** Goals & assumptions
:PROPERTIES:
:CUSTOM_ID: foreword__goals-&-assumptions
:END:

The basic goals are:

- highlight and explain interesting parts of Raku
- show and promote *contracts-based* programming style[fn:7] in Raku
- show a few (somewhat) useful scripts making use of the module

As for the assumptions, I expect my readers to be of two kinds, with greatly
differing characteristics. Here's a little table:

| Reader Type A                  | Reader Type B        |
|--------------------------------+----------------------|
| does not know Raku, at all     | knows Raku very well |
| is an intermediate+ programmer | knows Raku very well |
| knows 3+ languages very well   | knows Raku very well |

I expect *Type A* readers to learn a lot about Raku here, while I hope *Type B*
readers will learn a lot, but about /learning Raku/ instead - as seen from
beginner's perspective.

If you're neither *Type A* nor *Type B* - it might be a bit challenging or
boring read. Well, _give it a shot anyway_, seeing as you're on the page
already... ð

* Code
:PROPERTIES:
:CUSTOM_ID: code
:END:
** Overview
:PROPERTIES:
:CUSTOM_ID: code__overview
:END:

Raku source code is kept in files with =.raku= and =.rakumod= extensions[fn:8];
the former meant for scripts, the latter for... well, modules. We'll be creating
a bunch of modules and one script (in this section, there are some more files in
the following ones):

- =ShowTable.rakumod= - most of the functionality is here
- =Utils.rakumod= - a few general-purpose utils that stdlib lacks
- =Colors.rakumod= - helpers for handling colored text in tables
- =run.raku= - imports our modules and performs some tests

Let's start with the longest and most heavily commented file first:
=ShowTable.rakumod=, the heart of the library.

#+HTML: <div class="important">
#+HTML: <h4>Important note!</h4>

The code listings below are of two kinds: belonging to the code of the actual
module or script that is being discussed, and examples used purely for
illustration purposes. The code of the modules is _always displayed with line
numbers_, while examples are always without them. Also, in case it's not obvious
from context, you can hover with mouse over a block of code to _see the language
it is written in_.

#+HTML: </div>

** ShowTable.rakumod
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod
:END:
*** Module preamble
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__module-preamble
:END:

#+begin_src raku -n :tangle ShowTable.rakumod :eval no
  use v6.d;
#+end_src

Each file starts with a declaration of the minimum version of the language spec
required to run this code. Apparently, the =v6= part will remain that way
forever - as a bitter reminder of a historically bad decision to call Raku Perl6
at first. So, instead the major releases are identified by the letter after dot.
(Version "d", which apparently has code name "Diwali"[fn:9] [fn:19], is current, and
replaced "c" for "Christmas" in 2018)

#+begin_src raku +n :tangle ShowTable.rakumod :eval no
  unit module ShowTable;
#+end_src

Modules can be written like this:

#+begin_src raku
  module M {
      # functions, classes, etc. here
  }
#+end_src

but if there's just one module in a file, the =unit= qualifier comes in handy -
it treats the rest of the file as a module body.

You might notice that for some reason =unit= is not highlighted as a keyword on
Github. There's a sad story behind this[fn:10], so don't ask.

#+begin_src raku +n :tangle ShowTable.rakumod :eval no
  use Utils;
  use Colors :types;  
#+end_src

Once inside our module, we import two other modules. =use= statement loads them,
and then injects their exports into the current lexical scope, without warning
and with impunity. The module system in Raku gives /way too much power/ to the
module authors over what happens when their module is imported - it's especially
harmful because the defaults are bad. I'll say more about it when [[Module exports][discussing
exports]], below.

*** Subsets - common, run-time checked, constraints 
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__subsets---common,-run-time-checked,-constraints
:END:

If you know Racket, then subsets are [[https://docs.racket-lang.org/reference/contracts.html][simply flat contracts]].
# not like i had these all from the beginning...

Otherwise, you can think of them like this: a =subset= is a *named* set of
*assertions* about the shape or structure some value can take. Those assertions
can be *attached to variables, parameters, and functions*. Syntactically,
=subsets= can be used everywhere a simple type can, but checking if a value
fulfills the assertions is done at run-time, so the range of what you can check
for is much broader than with static types (in non-dependently-typed language,
anyway).

Another way of thinking about it is that subsets are syntactic sugar for the
more commonly used pre-conditions. If a pre-condition pops up in multiple
places, as long as it concerns a single variable or parameter, it can be
extracted into a named =subset=. This might not make much sense now, but after
seeing a few pre-conditions at work, it should become more apparent.

*One note:* these contracts are traditionally stored either at the top or at the
bottom of a file, here - at the top. They were not written all at once, and they
were closer to a place of use for most of the development time. In the first
version of the code, I used =Str= and =Int= everywhere, as any sane person
would. I then refined the contracts, trying to make them as precise as
practically relevant, over a few rounds of refactoring.

*Another note*: All of the constrained subtypes below are checked dynamically at
run-time. I honestly have no idea how expensive these are. I hope they get
inlined properly, at least.

The run-time impact of contracts like this is always an issue, traditionally
solved by disabling the checking of assertions in release mode. Unfortunately,
I'm not sure if it's possible to do this in Raku easily. In the worst case, I'd
have to edit the definitions below manually to comment out all the =where=
clauses, effectively transforming =subsets= into C-like =typedefs=.


#+begin_src raku +n :tangle ShowTable.rakumod :eval no :eval no
  subset Positive of Int where * > 0;            # same as { $_ > 0 }
  subset Character of Str where { .chars == 1 }; # same as { $_.chars == 1 }
                                                 # or as *.chars == 1
#+end_src

# NOTE: made a mistake, wrote .elem here instead of .chars, postcondition caught it!

The names of these should be descriptive enough. The part that would need an
explanation is probably just the one after =where=. What you put there has to be
a callable, and is executed every time the variable constrained with the given
=subset= is used.

About the "callable" part: it has to be a routine that accepts a single
parameter. Raku has quite a few ways of writing anonymous callables, here you
can see two: [[https://docs.raku.org/type/WhateverCode][WhateverCode]] and [[https://docs.raku.org/type/Block][Block]]. The first one forms a block whose single
argument is replaced for the star =*= in the enclosing expression. The other
forms a block with the first positional parameter assigned to a "topic
variable", called =$_=, inside the block (similar to how blocks in Groovy or
Kotlin use =it= as a default block argument name). 

Another bit of syntax: in a method call, if the object (or "invocant" in
Raku-speak) is missing, the method is called on the topic variable. Various
constructs set the topic variable, including =for=, =with=, and =given= keywords.

#+begin_src raku +n :tangle ShowTable.rakumod :eval no :eval no
  subset MaybeColoredStr where Str | Colored;
  subset ColumnSpec where Iterable | Int | Nil;
#+end_src

Ok, so you remember I told you that =where= needs to be passed a callable?
Actually, no, I lied. Well, simplified. The truth is you can put there anything
that you can use the =~~= "smart-matching" operator[fn:11] on. That operator
works mostly by calling a magic-method called =ACCEPTS= on RHS. Various "things"
implement that method, including - as you probably realized already - callables,
where smart-matching simply calls the routine with LHS operand as an argument.

So what you can put into =where= clause includes everything that works with
=~~=, which is basically anything. For simple values, smart-matching is
analogous to structural comparison (written as ~===~ normally), but for type and
role (interfaces, mixins) they perform an =.isa= or =.does= check on the LHS
value.

*TL;DR*: =MaybeColoredStr=, when used, will check whether a given value is a
=Str=, =Colored=, or any of their subclasses.

#+HTML: <div class="aside">
#+HTML: <h4>As an aside...</h4>

From what I can tell, that operator originated from Ruby (though I learned about
it in Smalltalk first), where it's called "case equality operator" or
"threequals". It's defined for =Object=[fn:12] as an alias for identity
comparison, but many subclasses override it to give it special semantics. Most
notably, =Proc=[fn:13], =Range=[fn:14], and =Regexp=[fn:15] classes implement
the ~===~ method, with semantics identical to the smartmatching on equivalent
classes in Raku. As in Raku, =Class= instances also implement the operator, with
it returning true when used on objects of a given type or any of its subtypes.

Note, however, that Ruby uses single-dispatch, so the order of arguments is
reversed compared to Raku; the code in Ruby:

#+begin_src ruby :results output :exports both
  puts Array === [3]
  puts (1..10) === 3
  puts -> x { x.integer? } === 3
  puts /some.*/ === "some string"
#+end_src 

#+RESULTS:
: true
: true
: true
: true

in Raku is written like this:

#+begin_src raku :exports both
  say 3 ~~ -> $x { $x.isa(Int) };
  say 3 ~~ (1..10);
  say [3] ~~ Array;
  say "some string" ~~ /some.*/;
#+end_src

#+RESULTS:
: True
: True
: True
: ï½¢some stringï½£

Also notice the regexp example: in Raku =~~= is more general and can return
results of types other than =Bool=, while the Ruby version is striclty a
query/predicate.

#+HTML: </div>



**** Junctions
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__subsets---common,-run-time-checked,-constraints__junctions
:END:

The last interesting bit of syntax, and an interesting concepts is "junctions".
Junctions are basically lazy conditions that aggregate a bunch of condition
subjects, and are responsible for applying a check to all junctions members and
combining results. You could do the same with collections, but the syntax of
junctions is much nices. Last example on junctions before moving on:

#+begin_src raku :results output :exports both
  say (my $ored = (3 | 4 | 5));      # is the same as: (3, 4, 5).any
  say (4 == $ored);
  say (4 == $ored).so;               # reduces to single value in boolen context
  say (my $anded = (3 & 4 & 5));     # is the same as: (3, 4, 5).all
  say ($anded â 1..10);              # â mean "is element of"
  say ($anded â 1..10).so;           # again, reduces to a single value
#+end_src

#+RESULTS:
: any(3, 4, 5)
: any(False, True, False)
: True
: all(3, 4, 5)
: all(True, True, True)
: True

Note: there's a Rakudo-specific function meant for debugging - called =dd= -
which prints a value and its type to stderr. Unfortunately, I can't use it in
examples because of this: my setup executes blocks and captures their outputs
automatically, but only uses =stdout= for this, not =stderr=... In any case, you
might want to use =dd= instead of =say= in the REPL or when pritntf-debugging.

Pay attention to the "is the same as" comments: you'll need them in the next
fragment!

#+begin_src raku +n :tangle ShowTable.rakumod :eval no
  subset StrList of Iterable where { .cache.all ~~ MaybeColoredStr };
  subset IntList of Iterable where { .cache.all ~~ Int };
  subset StrTable of Iterable where { .cache.all ~~ StrList };
#+end_src

These checks are *expensive*, and they may have unintended cosequences for some
of the =Iterable= sybtypes (eg. the lazy ones, hence the =.cache=[fn:16] call).
On the other hand, not having to worry about the shape of the data *at all*
within this module is too convenient to give up, and my use case does not
involve large input sizes.

#+begin_src raku +n :tangle ShowTable.rakumod :eval no
  enum JustifyType is export <None Left Right Center>;
#+end_src

There are some advantages to the use of enums... and then there's Raku which
eliminates almost all of them... ð No exhaustiveness checking, no distinct
identity for cases, no parametrization, just a little nicer syntax
for a named subset of literal values. Basically, it's an =enum= you know and
love from C, not a discriminated union you know and love *more* from ML.

And BTW, see this?

#+begin_src raku
  enum JustifyType is export <None Left Right Center>;
  #                            ð 
#+end_src

I wasn't intending on having this as an option, but then discovered that my
first option has a value of 0, which is treated as false in boolean context -
same as =Nil=. That means I'd need to check for definitedness (a way to discern
=Nil= from other falsey values) when using =JustifyType= with optional
arguments! I should probably just explicitly assign values to enums, but adding
=None= that would be 0/False kind-of-sort-of makes sense in this case, too.

*** Helpers for padding strings and lists
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__helpers-for-padding-strings-and-lists
:END:

I have to wonder, didn't NPM and /left-pad/ fiasco[fn:17] teach us all that
having no padding function in a standard library is a bad thing? (Well, among
other things about contemporary programmers' culture, but that's for another
time.) Most languages took it to heart; some examples:

- Python has =str.ljust, str.rjust, and str.center=
- Elixir has =String.pad_leading, String.pad_trailing= (no centering though)
- Nim has =strutils.{alignRight, alignLeft, center}=
- Haxe has =StringTools.{rpad, lpad}=
- Ruby has =String.{center, ljust, rjust}=
- Smalltalk (ST/X) has =CharArray>>{#paddedTo:, #leftPaddedTo:, #centerPaddedTo:}=
- Groovy has ={.padLeft, .padRight, .center}= added to =java.lang.String=

and so on... yet here Raku makes me code this by hand? Even Scala has at least
=String.padTo=! Or maybe I'm supposed to install a package just for this? I'm
still not quite sure what kinds of packages are there.

#+begin_src raku +n :tangle ShowTable.rakumod :eval no
  #| Pads given string with a given character up to a limit. Can pad on both
  #| sides.
  our sub str-justify(
      MaybeColoredStr $s,
      Positive $limit,
      JustifyType $type,
      Character $pad = " ",
      --> Str(MaybeColoredStr)
  ) is export(:tests) {
      PRE $s.chars <= $limit;
      POST $_â{ .no-color.chars == $limit } # NOTE: caught the problem with Character

      my $diff := $limit - $s.chars;
      given $type {
          when Left  { $s ~ ($pad x $diff); }
          when Right { ($pad x $diff) ~ $s; }
          when * { warn "Type {$type} not implemented yet!"; $s } # a bug here would be caught by the postcondition, too
      }
  }
#+end_src

**** Module exports
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__helpers-for-padding-strings-and-lists__module-exports
:END:

First: we're inside a module and we're defining names. By default, all names are
considered private to the enclosing module (thought they might be visible to whe
nested modules). That means there's no way to access the names declared that way
(with explicit or implicit =my=). As a module's author, you have to decide what
names should be accessible, and _how_.

We've seen it already, there's a =use= statement that allows users to depend on
the external module. However, what happens when that statement is executed is
almost entirely up to the module author. Here are the options and what happens
after =use= depending on your choice:

- use =our= instead of =my= qualifier for a name. This results in the name being
  accessible via Fully Qualified Name, that is,
  =ModuleName::name-of-our-symbol=.
- use =is export= trait on a name. This results in the name being injected
  directly into the current scope. Crucially, a name with this trait, but
  without =our= qualifier, *is not* accessible via FQN. You still can refer to
  the name with a qualified name, but it gets ugly:
  =ModuleName::EXPORT::ALL::exported-my-name=
- use =is export(:group1, :group2)= trait on a name. This is quite an original
  idea: inside a module, there can be any number of inner namespaces. This trait
  puts the name into one or more of them. The namespaces are created if they
  don't yet exist. Then, the user can import only names belonging to a
  particular group, like this: =use ModuleName :group1=.
- any combination of the above, with expected semantics. 

Here are some examples:

#+begin_src raku :results output :exports both
  module ModuleName {
      our sub f1()                              { "Called {&?ROUTINE.raku}" }
      my  sub f2() is export                    { "Called {&?ROUTINE.raku}" }
      my  sub f3() is export(:group1)           { "Called {&?ROUTINE.raku}" }
      our sub f4() is export                    { "Called {&?ROUTINE.raku}" }
      my  sub f5() is export(:DEFAULT, :group2) { "Called {&?ROUTINE.raku}" }
  }
  {
      say "Simple import:";
      import ModuleName;
      say ModuleName::f1(); 
      # say ModuleName::f2(); -- Error: Could not find symbol '&f2' in 'ModuleName'
      say f2();
      # say f3();             -- Error: Undeclared routine
      say f4();
      say f5();
  }
  {
      say "Group import:";
      import ModuleName :group1;
      say f3();
      # say f4(); -- Error: Undeclared routine
      say ModuleName::f1();
  }
#+end_src

#+RESULTS:
: Simple import:
: Called sub f1 { #`(Sub|6135037578944) ... }
: Called sub f2 { #`(Sub|6135025527520) ... }
: Called sub f4 { #`(Sub|6135037579064) ... }
: Called sub f5 { #`(Sub|6135037579184) ... }
: Group import:
: Called sub f3 { #`(Sub|6135025527400) ... }
: Called sub f1 { #`(Sub|6135037578944) ... }

**** Routine arguments
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__helpers-for-padding-strings-and-lists__routine-arguments
:END:

In Raku, arguments to routines can be constrained with a type, which can be
either a class, a role, or a subset, and also with =where= clauses (same meaning
as with subsets). NOTE: I'm not sure about scoping of identifiers in the =where=
clauses. In =sub f($a, $b, $c where { ... }, $d)=, in the =where= block, is =$d=
visible? Are =$a= and =$b= visible? Need to check.

Arguments can have default values.

**** First routine contracts
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__helpers-for-padding-strings-and-lists__first-routine-contracts
:END:

Routines can have contracts, too. First, the types and where clauses are routine
pre-conditions. These are checked before entering the routine. They mostly deal
with values of single arguments.

Then, there are explicit pre-conditions, in the form of =PRE= blocks. They
execute after type checks of arguments, but before anything else. They mostly
deal with relations between arguments.

Then, there are post-conditions, in the form of =POST= blocks. They execute
after the return value is known, but before final type check. =POST= blocks set
the return value as a topic variable, and they have access to all the function
arguments, too. 

NOTE: currently, =POST= blocks are executed even if the dispatch to the function
failed, or in other words: one or more arguments didn't meet the required
constrains. The construct =$_â{ ... }= uses a custom operator, =â=, to only call
the post-condition block when the returned value is defined - in the case of
dispatch failure it won't be. See more in [[Utils.rakumod]].

Finally, there's a type check provided by the function signature with either
=-->= arrow inside the argument list, or by adding one of the traits after the
closing paren: =returns(SomeType)= or =of SomeType= (I think, TODO)

**** Coercible types
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__helpers-for-padding-strings-and-lists__coercible-types
:END:

Variables and arguments can be told to accept types other then the one declared
and attempt to automatically convert the incoming type to the one declared. The
coercion happens by calling a method on the incoming value that has the same
name as the target type. This:

#+begin_src raku
  my Str(Any) $a = 2;
#+end_src

Tells variable =$a= to accept any kind of value that has =.Str= method, which is
then called before performing the assignment.

The same coercion can happen with the return type of a function, where the
return value is coerced to the required type before being returned.

**** Operators used
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__helpers-for-padding-strings-and-lists__operators-used
:END:

Raku allows defining custom operators, and also includes a multitude of
operators built-in. They are implemented as variants of one of the few
multi-methods. 

- =~= is string concatenation operator: ="a" ~ "b" eq "ab"= (BTW, =eq= is string
  equality)
- =x= is string repeat operator: ="a" x 5 eq "aaaaa"=
- =*= has a few meanings, but here it's used as an instance of =Whatever= type,
  which will match anything.

=given $obj { when 1 {}; when 2 {}; default {} }= is Raku version of
pattern-matching, but here it works like a simple =switch= statement from C (it
can do more, though).


# BTW: I think the module systems gives WAY too much to the module author. It's
# a module's user that should decide which identifiers they wish to have
# injected into often top-level module scope.

#+begin_src raku +n :tangle ShowTable.rakumod :eval no
  sub list-justify(
      Iterable $row,
      Positive $cols,
      Any :$fill = "",
      JustifyType :justify(:$type) = Left,
      --> List
  ) is export(:tests) {
      PRE $row.elems <= $cols; # TODO: description/extended name for the contract, { "jgvjv"; ...} or maybe  #= ?
      POST $_â{ .elems == $cols };  

      return $row if .elems == $cols;
      my $diff := $cols - $row.elems;
      my $fill-list := (1..$diff).map:{ my $ = $fill }; # any other way?
      given $type {
          when Left  { $row â $fill-list }
          when Right { $fill-list â $row }
          when * { warn "Type {$type} not implemented yet!"; $row  }
      }
  }
#+end_src

The two routines look very similar, but I'm not convinced DRYing them would be a
good idea. The =list-justify= is more general, and we could reduce =str-justify=
to a simple call to =list-justify=:

#+begin_src raku
  list-justify($s.comb, $limit, $pad).join;
#+end_src

But handling colored text would still need to be done somewhere, and I imagine
using Str-specific functions will be faster than converting back and forth
between Str and List. We could make both justify functions into a single
=multi=, but I don't think it would be any better then currently. Or would it?

To abstract over the kind of a thing we're padding/justifying further we would
need to take a bunch of functions/operators, namely for: getting length of the
thing, multiplying (repeating) the thing, and concatenating two things. It would
be ={.chars}=, =&infix:<~>=, =&infix:<x>=, respectively, for strings. It can be
done, but again, I don't see the reason to. 

Also, first-class functions, especially partially applied ones, are really bad
for performance on MoarVM. As you can read on the [[https://moarvm.com/roadmap.html][Roadmap page]], work on
optimizing this is ongoing:

#+begin_quote
Better optimization around closures

Today's optimizer does a poor job of, and has an inability to inline, first
class functions and closures. Recent work has started to collect the data needed
to do better; optimizations to exploit it are still to come.
#+end_quote

*** Formatting a single cell
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__formatting-a-single-cell
:END:

#+begin_src raku +n :tangle ShowTable.rakumod :eval no
  #| Make sure the returned string has exactly $limit characters, clipping or
  #| padding as needed.
  our sub format-cell(
      MaybeColoredStr $text,
      Positive $cell-width,
      JustifyType :justify(:$cell-justify-type) = Left,
      Character :$cell-padding = " ",
      --> Str(MaybeColoredStr)
  ) {
      POST $_â{ .no-color.chars == $cell-width };

      my Int $char-num := $text.chars;
      if $char-num > $cell-width {
          $text.substr(0, $cell-width - 1) ~ "â¦";
      }
      elsif $char-num < $cell-width && ?$cell-justify-type { 
          str-justify($text, $cell-width, $cell-justify-type, $cell-padding);
      }
      else {
          $text;
      }
  }
#+end_src

"Some people would have paused here and started making jokes about how Raku
can't have a "normal else if"... Whoever you are, please, don't be one of
people like *that*...""

*** Formatting the whole table
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__formatting-the-whole-table
:END:

In this routine, we make sure we're dealing with data of one shape only: a list
of rows of equal length, with each row being a list of strings. 

This assumption is expressed succintly and enforced by simply mentioning
=StrTable= in a type position. This assumption is costly to enforce, but frees
this routine from the need to handle most edge cases. 

There are two things that the =StrTable= contract doesn't enforce, so we check
for them in the first precondition. The =$table= has to be non-empty, and
lengths of each row have to be the same. The latter condition is important,
because it lets us rotate the table with =[Z]= meta-operator (see below) without
worrying about losing elements.


#+begin_src raku +n :tangle ShowTable.rakumod :eval no
  #| Create a multi-line string with values from $table aligned into columns.
  #| Passed $table cannot be empty.
  our sub format-table(
      StrTable $table is copy,
      Str :$col-separator = " ",
      Positive :$col-separator-width = 5,
      ColumnSpec :w(:chars(:$col-widths)) = Nil,
      Character :$cell-padding = " ",
      JustifyType :justify(:$cell-justify-type) = Left,
      --> Str
  ) is export {
      PRE $table.elems > 0 && [==] $tableÂ».elems; # NOTE
      PRE ($col-widths ~~ Iterable)â{ $col-widths.elems == $table[0].elems };

      my Str $fill := $col-separator x $col-separator-width;
      my @table = @$table;
      # NOTE: the [Z] @table doesn't work when there's only one row
      my $cols := @table.elems == 1 ?? @table[0].map(*.list) !! [Z] @table;

      for get-col-widths($col-widths, $cols).kv -> $col, $max {
          $cols[$col].=map: { format-cell($_, $max, :$cell-padding) }
      }
      # for @table { .join($fill).comb.raku.say }
      join "\n", (.join($fill) for @table);
  }

  our sub show-table(|args) is export {
      put format-table(|args);
  }
#+end_src

In some Lisps, there's a map-list/apply-map-list idiom[fn:18], which forms a
=zip= function. Raku has both =zip= function and a zip /operator/, =Z=; it has
also the =reduce= (often called =fold= or =fold-left=) function and
/meta-operator/ too, so the apply-map-list is written as essentially reduce-zip,
but with shorthand syntax: =[Z] list-of-lists=. It's a simple way of rotating
the table, from list of rows to a list of columns and vice versa.

*** Helpers for interpreting column widths argument
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__helpers-for-interpreting-column-widths-argument
:END:

TODO: first multi-method

#+begin_src raku +n :tangle ShowTable.rakumod :eval no
  multi get-col-widths(Int $width, @cols --> IntList) { $width xx @cols.elems }
  multi get-col-widths(Iterable $widths, @cols --> IntList) { $widths }
  multi get-col-widths($ where ?*.not, @cols --> IntList) { samewith(@cols) }

  multi get-col-widths(@cols where { .all ~~ StrList  } --> IntList) {
      POST $_â{ .elems == @cols.elems };
      my @widths[@cols.elems];
      @widths[$_] = (@cols[$_]Â».chars.max or 1) for @widths.keys;
      @widths
  }
#+end_src

*** Converting lists to tables - main API
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__converting-lists-to-tables---main-api
:END:

#+begin_src raku +n :tangle ShowTable.rakumod :eval no
  use Terminal::Width; # TODO: be smarter about cols number/width if not specified

  our sub to-table(StrList $seq, Int :$cols = 5 --> StrTable) is export {
      my $table := $seq.batch($cols)Â».Array.Array;
      $table.tail.=&list-justify($cols);
      $table
  }

  sub make-lorem-table(Int :r(:$rows), Int :$cols, Int :$max = 9 --> StrTable) is export(:tests) {
      to-table :$cols, (Utils::lorem-word($max) xx ($rows Ã $cols))
  }

  our sub show-list-in-table(
      StrList $seq, :$cols = 6, :$row-padding = " ", *%kwargs
  ) is export {
      $seq ==> to-table(:$cols) ==> show-table(|%kwargs);
  }
#+end_src

** Utils.rakumod
:PROPERTIES:
:CUSTOM_ID: code__utils.rakumod
:END:

#+begin_src raku -n :tangle Utils.rakumod :eval no
  use v6.d;

  unit module Utils;

  sub show-section-sep() is export { print "\n" ~ "=" x 10 ~ "\n" x 2; }
  sub show-subsection-sep() is export { print "\n" ~ "-" x 10 ~ "\n\n"; }

  multi sub show-section($enabled, &block) { samewith(&block) if $enabled; }
  multi sub show-section(&block) is export {
      show-section-sep;
      block();
      show-section-sep;
  }

  my @lorem-chars = [ |('a'..'z'), |('A'..'Z'), |('0'..'9') ];

  our sub lorem-word(Int $max = 9, Int $min = 3) is export {
      my $span = $min .. $max;
      @lorem-chars.roll($span.pick).join("")
  }


  our sub bench(Int $rep, &block) {
      my $times = do for ^$rep {
          block();
          now - ENTER now;
      }
      my ($fst, *$rest) = $times;
      say "Calls: $rep / ", $fst, " / ", do .sum / .elems with $rest;
  }


  our sub defined-and(Mu $x, &block) is export {
      return True unless $x.defined;
      block($x);
  }

  multi sub infix:<â>(Mu $x, &block) is export {
      return True unless $x.defined;
      block($x);
  }

  multi sub infix:<â>(Mu $x, &block) is export {
      return True unless $x.so;
      block($x);
  }


  # https://github.com/ajs/perl6-Operator-Listcat/blob/master/lib/Operator/Listcat.pm6
  multi sub infix:<listcat>(@a, @b) is equiv(&infix:<~>) is export { |@a, |@b }
  multi sub infix:<â>(Iterable $a, Iterable $b) is looser(&infix:<xx>) is export {
      |$a, |$b
  }


  our sub join-paths($base, $other --> IO::Path) is export { "$base/$other".IO }

  our sub list-dir($init where Str | IO::Path --> Seq) is export {
      my IO::Path @subdirs = [$init.IO.absolute.IO];
      gather while @subdirs {
          my $cur = @subdirs.shift(); # say $cur;
          my $seq := $cur.dir.cache;
          my ($, $dirs, $files) =
              take ($cur, $seq.grep(*.d)Â».basename, $seq.grep(*.d.not)Â».basename);
          my &absolutize := { join-paths($cur, $_) }
          @subdirs.prepend: $dirsÂ».&absolutize;
      }
  }

#+end_src

** Colors.rakumod
:PROPERTIES:
:CUSTOM_ID: code__colors.rakumod
:END:

#+begin_src raku -n :tangle Colors.rakumod :eval no
  use v6.d;

  use MONKEY; # ð - because augmenting existing classes is very bad for
              # performance; which is strange, b/c Smalltalk - see note

  unit module Colors;

  use Terminal::ANSIColor;


  our class Colored is export(:types) {
      has Str $.style;
      has Str $.string handles ("chars");

      method new($str, $style) {
          self.bless(style => $style, string => $str)
      }
      method substr(::?CLASS:D: |args) {
          $!string.=substr(|args);
          self.Str;
      }

      method in-color(Str $!style) {}

      method no-color() {
          $!string
      }

      method Str() { $!string.&colored($!style) }
  }


  augment class Str {
      method in-color(Str:D : Str $c) {
          Colored.new(self, $c)
      }

      method no-color(Str:D:) {
          colorstrip(self)
      }
  }
#+end_src

* Examples of use
:PROPERTIES:
:CUSTOM_ID: examples-of-use
:END:
** Meta.rakumod - introspect classes and object
:PROPERTIES:
:CUSTOM_ID: examples-of-use__meta.rakumod---introspect-classes-and-object
:END:

#+begin_src raku -n :tangle Meta.rakumod :eval no
  use v6.d;

  unit module Meta;

  use Terminal::ANSIColor;

  use Utils;
  use ShowTable;


  my $package-names = (
      "MY", "OUR", "CORE", "GLOBAL", "PROCESS", "CALLER", "CALLERS",
      "DYNAMIC", "OUTER", "OUTERS", "LEXICAL", "UNIT", "SETTING", "PARENT",
      "CLIENT"
  );

  # change my -> our to make all the functions available at once when testing
  module Priv {
      use Utils;

      sub all-caps(Str $s --> Bool()) is export {
          $s.match: / ^(<upper>|<[-&$@_%!]>)+$ /;
      }

      sub show-class-header(Mu \obj) is export {
          say (
              "Class",
              colored(obj.^name, "green"),
              "is:",
              colored(obj.^mro.raku, "yellow"),
              "does:",
              colored((try obj.^roles.raku) || "<ERROR>", "bold")
          ).join(' ');
      }

      sub natural-ordering(Str $a, Str $b) is export {
          my ($caps-a, $caps-b) = (all-caps($a), all-caps($b));
          # dd $caps-a, $caps-b, $a, $b;
          my Order $ret = do {
              when $caps-a  && $caps-b  { $a cmp $b }
              when $caps-a  && !$caps-b { Less }
              when !$caps-a && $caps-b  { More }
              default                   { $a cmp $b }
          }
          # dd $ret;
          $ret
      }

      sub sort-by-name(Iterable $seq) is export {
          $seq.sort({ natural-ordering($^a.name, $^b.name) })
      }


      sub classify-symbols($seq) is export {
          $seq.classify: {
              when all-caps(.name) { 'caps' }
              when .name.match(/^<upper>/) { 'upper' }
              default { 'lower' }
          }
      }
  }

  import Priv;


  # ==============================================================================


  our sub meths(Mu \obj) is export {
      show-section-sep;
      show-class-header(obj);
      print "\n";

      my $rows = sort-by-name(obj.^methods.unique(:as(*.name))).map: {
          (colored(.name, "yellow"), .signature.raku, (try "{.file} : {.line}") || "<BUILT-IN>")
      };
      show-table($rows, :widths(15, 40, 40));
  }


  our sub doc($query, :l(:$lines) = 15) is export {
      my $res = qqx[ rakudoc '$query' ];
      if $res {
          say $res.lines[^$lines].join("\n")
      };
      "";
  }


  our sub cls(Mu \obj) is export {
      my $m = obj.^methods.unique(:as(*.name));
      my %m = classify-symbols($m);
      show-section-sep;
      show-class-header(obj);
      for <caps upper lower> {
          FIRST show-subsection-sep;
          sort-by-name(%m{$_})>>.name ==> show-list-in-table(:5cols) if %m{$_}:exists;
          show-subsection-sep;
      }
  }


  our sub ns($pkg) is export {
      # EXPORT::ALL::.keys
      say $pkg.^name;
      # say ::("CALLER")::EXPORT::ALL::.keys;
      # $package-names.map({ "- " ~ (try { $_ ~ " " ~ ::("$_")::.keys.raku } || $_ )})>>.say;
  }

#+end_src

** pkgs.raku - show a list of available packages
:PROPERTIES:
:CUSTOM_ID: examples-of-use__pkgs.raku---show-a-list-of-available-packages
:END:

#+begin_src raku -n :tangle pkgs.raku :eval no
  use v6.d;

  use JSON::Fast;

  use Colors;
  use ShowTable;
  use Utils;


  sub dt(Str $s --> Str) {
      with $s.DateTime {
          (.year, "-", .month.fmt('%02d'), "-", .day.fmt('%02d') ).join
      }
  }

  show-section 1, {
      my constant $fields := <name updated eco likes desc>;
      my constant $widths := [25,  10,     5,  3,    60];

      my @table = [];

      for "raku.pkgs".IO.lines -> $line {
          my $rows := $line.&from-json()>>.{ $fields };
          next unless $rows;
          my $cols := [Z] $rows;
          $cols[1].=map(&dt);     # Why is it working? What made $cols mutable?
          $rows := [Z] $cols;
          @table.append($rows);
      }
      @table.=squish(as => { .[0].lc });
      @table.=grep({ (.[0] | .[4]) ~~ rx:i/term/ });
      dd @table;
      show-table(@table, :col-widths($widths));
  }
#+end_src

* Other scripts
:PROPERTIES:
:CUSTOM_ID: other-scripts
:END:
** watch.raku - watch files for changes
:PROPERTIES:
:CUSTOM_ID: other-scripts__watch.raku---watch-files-for-changes
:END:
Re-runs a command if one of the watched files changes.

#+begin_src raku -n :eval no
  use v6.d;

  use Utils;
  use Colors;
  use ShowTable;

  constant Change = IO::Notification::Change;

  constant $command = "raku -Iraku raku/run.raku";


  sub re-run(Change $change) {
      my $path := $change.path;
      put "$path changed, running command:\n\t$command";
      my $status = shell($command).exitcode;
      my $color = $status ?? "red" !! "green";
      put "\n==========\n".indent(4).in-color($color);
      my $elapsed = now - ENTER now;
      put "Elapsed: $elapsed".indent(4).in-color($color);
      if $status == 0 {  qqx[ noti -m "$elapsed" -t "OK" ];    }
      else            {  qqx[ noti -m "$elapsed" -t "ERROR" ]; }
  }

  sub MAIN(Str $base) {
      my @files = dir($base).grep(/ '.raku'('mod')? $/).grep(none /watch/);
      say "Watching: "; @filesÂ».absolute.map(*.indent(4).say); say "";
      loop {
          my $supply = @filesÂ».watch.reduce({ $^a.merge($^b) });
          react {
              whenever $supply { re-run($_); done }
              # ie. either got Ctrl+C or this file changed
              whenever signal(SIGINT) | $?FILE.IO.watch { exit }
          }
          $supply = Nil;
      }
  }
#+end_src

* COMMENT ...
:PROPERTIES:
:CUSTOM_ID: ...
:END:

** fragments
:PROPERTIES:
:CUSTOM_ID: ...__fragments
:END:

# my constant Change = IO::Notification::Change;
# apparently, selective import is something that needs to be delegated to the
# ecosystem. There are some modules available, but for the simple case of
# shortening package-qualified names this construct suffices. BTW, the defaults
# for the module system are really bad in Raku. Well, better than Ruby, but
# still.


interested in the [[https://raku.org][Raku]] programming language. I even have a proper use-case this
time! Put simply: I want a shell-script replacement that is much safer to use
than BASH, but also more succint than Python. Another thing: I'd prefer a
general-purpose language, thank you for the suggestion, but no Elvish, Murex,
Oil, etc. Moving on:


So it started from the REPL. You see, you can check what methods has any given
object if you invoke a metaclass method called ~methods~. This is the same
approach as in Smalltalk/X:

#+begin_src smalltalk :eval no
  2 class getMethodDictionary keys.
  "OrderedCollection(#'*' #'+' #'-' #'/' #'//' #'\\' #abs #negated #quo: #bitAnd: #bitClear: #bitCount #bitInvert ....etc)"
#+end_src

in Raku this is written:

#+begin_src raku
  2.^methods
#+end_src

I mean, something about ~^~ character and "higher level", meta-programming? It's
just basic introspection though... 

In any case, the problem is in how the methods returned are represented, and
displayed. By default it looks like this:

#+begin_src text
  (new Capture Int sign Num Rat FatRat abs Bridge sqrt base polymod expmod is-prime floor ceiling round lsb msb narrow Range conj rand sin asin cos acos tan atan atan2 sec asec cosec acosec cotan acotan sinh asinh cosh acosh tanh atanh sech asech cosech acosech cotanh acotanh unpolar cis Complex log exp truncate isNaN log2 log10 roots succ pred WHICH ACCEPTS raku Bool Str Real Numeric gist DUMP BUILDALL chr unimatch uniname uniprop unival)
#+end_src

and, coupled with acute lack of screen real-estate, would be presented like
this:


Unnecessary addendum: you know when was the last time I've seen a REPL this
pretty? When working with FORTH. Really:


Hopefuly your shell would have wrapped the line for you, but that doesn't help
with readability much. It's possible to print each method in its own line
easily, but then there's too much space wasted, and you have to scroll to see
the beginning of the list, which is also less convenient then it could be.

So, to make the introspection a little more helpful, and for science of course!,
I decided to write a module for printing tables in a terminal. There are some
similar packages on https://raku.land, but neither one is exactly what I want,
and anyway, at that point I didn't think such a thing would be package-worthy on
its own. 

** Workflow!

Org -> HTML export -> Grammarly -> Clipboard2Markdown -> pandoc MD -> Org again

https://euangoddard.github.io/clipboard2markdown/

pandoc -f markdown -t org -o fname.org fname.md

sprawdzic, czy moze czytac z stdin i dumpowac na stdout
owinac w komende emacsowa

** some code

#+begin_src raku :eval query :results output :exports both
  my @types = 
      Q{AST},
      Q{Allomorph},
      Q{Any},
      Q{Array},
      Q{Associative},
      Q{Attribute},
      Q{Awaitable},
      Q{Awaiter},
      Q{Backtrace},
      Q{Bag},
      Q{BagHash},
      Q{Baggy},
      Q{BigEndian},
      Q{Blob},
      Q{Block},
      Q{Bool},
      Q{Broken},
      Q{Buf},
      Q{CX},
      Q{CallFrame},
      Q{Callable},
      Q{Cancellation},
      Q{Capture},
      Q{Channel},
      Q{Code},
      Q{Collation},
      Q{CompUnit},
      Q{Compiler},
      Q{Complex},
      Q{ComplexStr},
      Q{ContainerDescriptor},
      Q{Cool},
      Q{CurrentThreadScheduler},
      Q{Cursor},
      Q{Date},
      Q{DateTime},
      Q{Dateish},
      Q{Deprecation},
      Q{Distribution},
      Q{Distro},
      Q{Duration},
      Q{EXPORTHOW},
      Q{Empty},
      Q{Encoding},
      Q{Endian},
      Q{Enumeration},
      Q{Exception},
      Q{Exceptions},
      Q{Failure},
      Q{False},
      Q{FatRat},
      Q{FileChangeEvent},
      Q{FileChanged},
      Q{FileRenamed},
      Q{ForeignCode},
      Q{Grammar},
      Q{HardRoutine},
      Q{Hash},
      Q{Hyper},
      Q{HyperConfiguration},
      Q{HyperSeq},
      Q{HyperWhatever},
      Q{IO},
      Q{Inf},
      Q{Instant},
      Q{Int},
      Q{IntAttrRef},
      Q{IntLexRef},
      Q{IntPosRef},
      Q{IntStr},
      Q{Iterable},
      Q{IterationBuffer},
      Q{Iterator},
      Q{JSONException},
      Q{Junction},
      Q{Kept},
      Q{Kernel},
      Q{Label},
      Q{Less},
      Q{List},
      Q{LittleEndian},
      Q{Lock},
      Q{Macro},
      Q{Map},
      Q{Match},
      Q{Metamodel},
      Q{Method},
      Q{MethodDispatcher},
      Q{Mix},
      Q{MixHash},
      Q{Mixy},
      Q{More},
      Q{Mu},
      Q{MultiDispatcher},
      Q{NFC},
      Q{NFD},
      Q{NFKC},
      Q{NFKD},
      Q{NQPMatchRole},
      Q{NQPdidMATCH},
      Q{NaN},
      Q{NativeEndian},
      Q{Nil},
      Q{Num},
      Q{NumAttrRef},
      Q{NumLexRef},
      Q{NumPosRef},
      Q{NumStr},
      Q{Numeric},
      Q{NumericEnumeration},
      Q{NumericStringyEnumeration},
      Q{ObjAt},
      Q{Order},
      Q{PF_INET},
      Q{PF_INET6},
      Q{PF_LOCAL},
      Q{PF_MAX},
      Q{PF_UNIX},
      Q{PF_UNSPEC},
      Q{PROCESS},
      Q{PROTO_TCP},
      Q{PROTO_UDP},
      Q{Pair},
      Q{ParallelSequence},
      Q{Parameter},
      Q{Perl},
      Q{PhasersList},
      Q{Planned},
      Q{Pod},
      Q{Positional},
      Q{PositionalBindFailover},
      Q{PredictiveIterator},
      Q{Proc},
      Q{Promise},
      Q{PromiseStatus},
      Q{ProtocolFamily},
      Q{ProtocolType},
      Q{Proxy},
      Q{PseudoStash},
      Q{QuantHash},
      Q{REPL},
      Q{RaceSeq},
      Q{Raku},
      Q{Rakudo},
      Q{Range},
      Q{Rat},
      Q{RatStr},
      Q{Rational},
      Q{Real},
      Q{Regex},
      Q{Routine};

  for @types.map({ ::($_) }) -> Mu $_ is raw {
      next unless .HOW ~~ Metamodel::ClassHOW;
      my $does-iterable = $_ ~~ Iterable ?? 'does Iterable' !! "";
          my $sports-iterator = .^methods(:local)Â».name.any eq 'iterator' ?? 'sports iterator' !! "";
          my $and = $does-iterable & $sports-iterator ?? ' and ' !! '';
          next unless $sports-iterator | $does-iterable;

          say .^name, ' ', $does-iterable, $and, $sports-iterator;
      }
#+end_src

#+RESULTS:
#+BEGIN_EXAMPLE
  Any sports iterator
  Array does Iterable and sports iterator
  Bag sports iterator
  BagHash sports iterator
  Channel sports iterator
  Failure sports iterator
  Hash does Iterable
  HyperSeq does Iterable and sports iterator
  IterationBuffer sports iterator
  Junction sports iterator
  List does Iterable and sports iterator
  Map does Iterable and sports iterator
  Mix sports iterator
  MixHash sports iterator
  Mu sports iterator
  Nil sports iterator
  Pair sports iterator
  PseudoStash does Iterable
  RaceSeq does Iterable and sports iterator
  Range does Iterable and sports iterator
  Routine sports iterator
#+END_EXAMPLE

* Footnotes
:PROPERTIES:
:CUSTOM_ID: footnotes
:END:

[fn:20] https://awesomewm.org/ 

[fn:19] See [[https://github.com/Raku/roast/blob/master/docs/announce/6.d.md][release announcement on GitHub]] and [[http://blogs.perl.org/users/zoffix_znet/2018/11/announce-raku-perl-6-diwali-6d-language-specification-release.html][associated blog post]].

[fn:1] Though methodology there is a bit questionable, at best. Plus, it's from
2013, and many languages didn't make it onto a list, and there are multiple
languages that faded into (even more) obscurity since then.

[fn:2] [[https://coffeescript.org/][CoffeeScript]] was in top 5 languages in the study, and LiveScript is even
more succint than Coffee.

[fn:3] see [[http://literateprogramming.com/][Literate Programming homepage]] and [[https://en.wikipedia.org/wiki/Literate_programming][LP Wiki page]] to get a general idea.

[fn:4] [[https://orgmode.org/][Org Mode Homepage]]

[fn:5] [[https://orgmode.org/manual/Working-with-Source-Code.html#Working-with-Source-Code][Working with Source Code in Org]]

[fn:6] See [[https://raku.land/github:thundergnat/Terminal::Boxer][Terminal::Boxer]] or [[https://raku.land/github:ab5tract/Terminal::Print][Terminal::Print]] or [[https://raku.land/?q=table][any of the multitude of other
packages]].

[fn:7] As implemented in Racket, which is a bit different than the original
Eiffel implementation. This is why I write about "contracts-based" programming
instead of using the more specific [[https://en.wikipedia.org/wiki/Design_by_contract][Design by Contract]] term. Other than in Racket
docs, there's a book [[https://htdp.org/2020-5-6/Book/index.html]["How to Design Programs"]] which uses this style throughout.

[fn:8] I think these are now recommended; there seem to be a few other
extensions, either used for specific things like tests (with =.t=), or
deprecated ones based on previous name of the language, eg. =.pm6=.

[fn:9] [[https://en.wikipedia.org/wiki/Divali][Annual festival of light]] in Hinduism, happening for a few days in October
and November... apparently.

[fn:10] Apparently, a person responsible for writing syntax highlighting died in
a traffic accident before being able to finish. [[https://en.wikipedia.org/wiki/Bus_factor][Bus factor]] is not always only a
metaphor - it can happen in real life too.

[fn:11] [[https://docs.raku.org/routine/~~][~~ routine]] docs

[fn:12] [[https://ruby-doc.com/core/Object.html#method-i-3D-3D-3D][Object.===]] docs

[fn:13] [[https://ruby-doc.com/core/Proc.html#method-i-3D-3D-3D][Proc.===]] docs

[fn:14] [[https://ruby-doc.com/core/Range.html#method-i-3D-3D-3D][Range.===]] docs

[fn:15] [[https://ruby-doc.com/core/Regexp.html#method-i-3D-3D-3D][Regexp.===]] docs

[fn:16] [[https://docs.raku.org/routine/cache#(Any)_method_cache][Any.cache method]] docs

[fn:17] If you need refresher - I needed - [[https://www.davidhaney.io/npm-left-pad-have-we-forgotten-how-to-program/][here's the first googled article]].

[fn:18] In Racket: =(apply map list '((a b) (c d))) ;=> '((a c) (b d))=

# Local Variables:                                                 #
# eval: (add-hook 'after-save-hook 'my-upload-raku-writeup nil t)  #
# eval: (add-hook 'after-save-hook 'org-html-export-to-html nil t) #
# eval: (add-hook 'after-save-hook 'org-babel-tangle nil t)        #
# End:                                                             #
