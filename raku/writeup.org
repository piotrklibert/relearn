#+TITLE: Printing tables in terminal with Raku
#+OPTIONS: inline:t toc:3
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/bigblow.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/hideshow.css"/>

#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>

#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
# #+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <style type="text/css"> pre { background-color: #232324 !important; color: white;  } .src-smalltalk, .src-text { color: white !important; } </style>

* Foreword
:PROPERTIES:
:CUSTOM_ID: foreword
:END:

** Time to learn something new!
:PROPERTIES:
:CUSTOM_ID: foreword__time-to-learn-something-new!
:END:

It's been quite a long time since I last learned a new programming language that
was even a bit interesting. I learned [[https://www.lua.org/][Lua]], [[https://moonscript.org/][MoonScript]], and then [[https://haxe.org/][Haxe]] to script
my window manager, then came back to [[https://www.gnu.org/software/smalltalk/][Smalltalk]] trying to create a multi-player
shell in it, and more recently I learned [[https://www.rust-lang.org/][Rust]] for [[https://webassembly.org/][WebAssembly]] development. It's
been more than 3 months since then, so it's time to move on again! (Update: I'm
getting back to Smalltalk - I think of reviving my shell project using Visual
Works...)

This time I wanted a language that I could use for quick, often one-off, scripts
for command line. Instead of a traditional mixture of =sed=, =AWK=, =BASH=, and
=Python=, I wanted one language that could perform all their functions in a
day-to-day scripting.

One of the most important requirements for that language was that I don't know
it yet (I could compromise on that only if there were no such candidates). Other
than that, I wanted something *succint* and *expressive*, supporting creation of
*internal DSLs*. Finally, I wanted a language with features helpful in assuring
*correctness* of programs written in it.

*** Eliminations
:PROPERTIES:
:CUSTOM_ID: foreword__eliminations
:END:

After preliminary investigation and some research, out of [[https://klibert.pl/timeline.png][quite a few]] languages
that I know, plus some more that [[https://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/][came up]] when researching[fn:1] the topic, only
a few languages remained. These were:

- [[http://www.rebol.net/][REBOL]] or [[https://www.red-lang.org/][Red]]
- [[https://clojure.org/][Clojure]], or rather [[https://clojurescript.org/][ClojureScript]] on Node.js
- [[https://livescript.net/][LiveScript]][fn:2] on Node.js 
- [[https://racket-lang.org/][Racket]] on Chez Scheme
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html][Emacs Lisp]] with ~emacs --batch~
- [[https://www.scala-lang.org/][Scala]] on JVM
- [[https://raku.org/][Raku]] on [[https://moarvm.com/][MoarVM]]

Out of these, the only ones that I don't know at all were REBOL, Red, and Raku.

It's hard to say how actively developed REBOL is, and I don't quite trust its
development model. Red is an interesting proposition, but it's immature, and I
don't quite agree with the team's priorities. Raku seemed more actively
developed than REBOL and more mature than Red.

*TL;DR*: only *Raku* was left standing, with corpses of other contenders piled
up in a corner. Playing with *Raku* will be fun, will be fun, will be fun... for
a while.

# (I excluded some extreme cases, like Haskell, J, or FORTH)

# All worth considering, but most have things that made me pass on them. For
# example, I don't 100% trust the REBOL model of development, and Red is still a
# decade before half if its promises materialize. I know Scala already, but it's
# in a dangerous period right now - a Python-like phase-transition from 2.x to
# 3.x - and I'd rather wait that one out. Clojure on its own is a hard pass,
# because of the startup time. But ClojureScript runs on Node - worth considering,
# but I already know Clojure, so maybe another day. Racket is always, always in my
# heart[fn:4], but I've been playing with too many Lisps as of late anyway.

# LiveScript has a lot of syntactic sugar that's similar to Raku, Perl, and
# Haskell, plus it has access to NPM. Similarly, Emacs Lisp is surprisingly an
# extremely capable language - incredible amount of work went into both the
# implementation, stdlib, and libraries - there's more Elisp packages than Raku
# packages in their respective package repositiories. But, I know both Elisp and
# LS, use then constantly, which would make the whole thing much less interesting.

** What's up with this article?
:PROPERTIES:
:CUSTOM_ID: foreword__so-what's-up-with-this-article
:END:

*** Motivation

Well, I decided to document my learning of Raku somehow. 

The usual process I take with most new languages is a bit complex; it's split
into a few stages/phases, and one of them is supposed to end with Â±500 lines of
working code. That code is supposed to use minimal external dependencies - just
base language and its stdlib. This happens to be where I am today with Raku (for
reference: May 5th, 2022).

Getting to this point, in Raku's case, wasn't very hard, but what made it more
complicated was complete lack of materials of a certain type: ones that would
give an overview of the more interesting or advanced features of the language. I
found three types of resources:

1. "Whirlwind tour"-style, very short, with very little (if any) explanation.
2. Bite-sized blog posts on what to do in a certain situation.
3. Long and detailed reference manuals in the official docs.

What I felt was sorely missing was basically an aggregation of pt. 2. posts,
with some additional explanation and links to the docs where needed.

I thought that I might as well contribute something to improve the situation.
This article is an attempt at that. At the same time, I'm trying to give
feedback to the community on how its learning materials fare from the
perspective of a beginner. I'm cheating, of course: I am by no means a beginner
in *learning* programming languages, but in this case I think that would be an
advantage

*** The article formula

To serve both purposes - to help future Raku beginners and to help community
improve learning materials - I thought it would be best to start with the code I
wrote during learning. This way I can both explain the reasons for using a
feature (would be harder with someone else's code) and describe my experience of
learning about it.

In the end, I decided to turn the code I had - a simple package for printing
text in columns - into a Literate Programming[fn:3] document. LP is a way of
writing code that interleaves rich documentation with actual code. It's
especially easy to do this due to Emacs, Org Mode[fn:13], and Babel[fn:14]. You
can read the document in its intended form either on Github, or on my site:

- [[https://github.com/piotrklibert/relearn/blob/master/raku/writeup.org][version in GitHub]]
- [[https://klibert.pl/statics/raku/writeup.html][self-hosted article]] (recommended)

*** Disclaimer and fair warning

I read a bunch of docs and wrote some trivial code. That's the extent of my
knowledge. Don't expect the code to be idiomatic - if it happens to be, that's
by accident or mistake. I provide my explanations on an "as is" basis, without
any warranty whatsoever. I'm writing from a perspective that allows me to be
wrong, a lot, without consequences, so I probably *will* be wrong. I do accept
PRs with corrections, though...

At this point, after this article, I should be advancing to the next stage. To
show you that I *am* paying attention and plan to dig deeper, here's a list of
things that I did not yet have time to investigate:

- how other similar packages[fn:12] are written
- what general-purpose, quality-of-life improving utilities are available
- the plans for the future and what is currently being implemented in Rakudo
- the details of how the work is split between  Rakudo, NQP, and MoarVM 
- what is it about RakuAST and if it's possible the macros become usable
- what is written in The Official Raku Test Suite (ROAST)
- what is happening in Raku's blog-o-sphere, including archives & current threads
- who the main contributors are, what vision do they try to follow
- how good is Comma IDE, a Raku-dedicated environment (the one and only)
- how various constructs are implemented, including junctions and subsets
- details of the meta-model - metaclasses, method objects, traits (but see note)
- what is the performance in various conditions - I only have anecdata
  (sample: 1)
- why does =[Z]= (and even just repeated =Z= applications) work

https://github.com/Raku/roast/blob/master/docs/announce/6.d.md
http://blogs.perl.org/users/zoffix_znet/2018/11/announce-raku-perl-6-diwali-6d-language-specification-release.html


Moreover, I didn't track the history of Raku, nor its prehistory (ie. Perl 5).
Everything I write is based on roughly 4 weeks of afternoon sessions with docs
and Google, as they were in _April-May 2022_.

# > 1.HOW
# Perl6::Metamodel::ClassHOW.new
# > 1.HOW.HOW
# (low-level object `NQPClassHOW`)
# > 1.HOW.HOW

** The example - aligning strings in columns
:PROPERTIES:
:CUSTOM_ID: foreword__so-what-are-we-going-to-build
:END:

The module we're going to write is a simple utility for printing tables - that
is, a bunch of strings aligned into columns - in a terminal. The module should
be able to also handle colored (or otherwise styled) text, where some parts of
the string are control sequences that are not displayed (and hence need to be
ignored when computing the width of a string).

The module should be somewhat configurable - the user should be able to choose
padding characters, columns width, alignment type - but it's not going to be a
full TUI framework. It's just an example. If you want to add interactivity,
multiline cells, borders, etc. - there are already much better packages[fn:12]
available!

That's it. Here's the end result (the characters used to pad cells and columns
are obviously configurable): 

#+HTML: <img src="./img/end-result.png" width="60%" />

Here it's used to interrogate an object in the REPL:

#+HTML: <img src="./img/meta.png" width="60%" />

And here's an example of use for displaying tabular data from JSON:

#+HTML: <img src="./img/pkgs.png" width="60%" />

** Goals & assumptions

The basic goals are:

- highlight and explain interesting parts of Raku
- show and promote *contracts-based* programming style[fn:11] in Raku
- show a few (somewhat) useful scripts making use of the module

As for the assumptions, I expect my readers to be of two kinds, with greatly
differing characteristics. Here's a little table:

| Reader Type A                | Reader Type B        |
|------------------------------+----------------------|
| does not know Raku, at all   | knows Raku very well |
| is intermediate+ programmer  | knows Raku very well |
| knows 3+ languages very well | knows Raku very well |

There you have it. If you're neither A nor B - it's probably going to be a
really boring read. Well, give it a shot anyway, seeing as you're on the page
already...

* Code
:PROPERTIES:
:CUSTOM_ID: code
:END:
** Overview
:PROPERTIES:
:CUSTOM_ID: code__overview
:END:

Raku source code is kept in files with =.raku= and =.rakumod= extensions[fn:4];
the former meant for scripts, the latter for... well, modules. We'll be creating
a bunch of modules and one script (in this section, there are some more files in
the following ones):

- =ShowTable.rakumod= - most of the functionality is here
- =Utils.rakumod= - a few general-purpose utils that stdlib lacks
- =Colors.rakumod= - helpers for handling colored text in tables
- =run.raku= - imports our modules and performs some tests

Let's start with the longest and most heavily commented file first:
=ShowTable.rakumod=, the heart of the library.

*NOTE:* the code listings below are of two kinds: belonging to the code of the
actual module or script, and examples for illustration purposes. The code of the
module is *always displayed with line numbers*, while examples are without them.

** ShowTable.rakumod
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod
:END:
*** Module preamble
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__module-preamble
:END:

#+begin_src raku -n :tangle ShowTable.rakumod
  use v6.d;
#+end_src

Each file starts with a declaration of the minimum version of the language spec
required to run this code. Apparently, the =v6= part will remain that way
forever - as a bitter reminder of a historically bad decision to call Raku Perl6
at first. So, instead the major releases are identified by the letter after dot.
(Version "d", which apparently has code name "Diwali"[fn:5], is current, and
replaced "c" for "Christmas" in 2018)

#+begin_src raku +n :tangle ShowTable.rakumod
  unit module ShowTable;
#+end_src

Modules can be written like this:

#+begin_src raku
  module M {
      # functions, classes, etc. here
  }
#+end_src

but if there's just one module in a file, the =unit= qualifier comes in handy -
it treats the rest of the file as a module body.

You might notice that for some reason =unit= is not highlighted as a keyword on
Github. There's a sad story behind this[fn:6], so don't ask.

#+begin_src raku +n :tangle ShowTable.rakumod
  use Utils;
  use Colors :types;  
#+end_src

Once inside our module, we import two other modules. =use= statement loads them,
and then injects their exports into the current lexical scope, without warning
and with impunity. The module system in Raku gives /way too much power/ to the
module authors over what happens when their module is imported - it's especially
harmful because the defaults are bad. I'll say more about it when discussing
exports below.

*** Subsets - common, run-time checked, constraints 
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__subsets---common,-run-time-checked,-constraints
:END:

If you know Racket, then subsets are [[https://docs.racket-lang.org/reference/contracts.html][simply flat contracts]].

Otherwise, you can think of them like this: a =subset= is a *named* set of
*assertions* about the shape or structure some value can take. Those assertions
can be *attached to variables, parameters, and functions*. Syntactically,
=subsets= can be used everywhere a simple type can, but checking if a value
fullfils the assertions is done at run-time, so the range of what you can check
for is much wider than with static types (in non-dependently-typed language,
anyway).

Another way of thinking about it is that subsets are syntactic sugar for the
more commonly used pre-conditions. If a pre-condition pops up in multiple
places, as long as it concerns a single variable or parameter, it can be
extracted into a named =subset=. This might not make much sense now, but after
you see a few pre-conditions at work, it should become clearer.

# not like i had these all from the beginning...

*One note:* these contracts are traditionally stored either at the top or at the
bottom of a file, here - at the top. They were not written all at once, and they
were closer to a place of use for most of the development time. In the first
version of the code I used =Str= and =Int= everywhere, like a sane person would.
I then started refining the contracts, trying to make them as precise as
practically relevant, over a few rounds of refactoring.

*Another note*: All of the constrained subtypes below are checked dynamically,
at run-time. I honestly have no idea how expensive these are. I hope they get
inlined properly, at least. 

In any case, run-time impact of contracts like this is always an issue,
traditionally solved by disabling checking of assertions in release mode. I'm
not sure if it's possible to easily do this in Raku: in the worst case I'd have
to edit the definitions below manually to comment out all the =where= clauses,
effectively transforming =subset= into a C-like =typedef=.


#+begin_src raku +n :tangle ShowTable.rakumod
  subset Positive of Int where * > 0;            # same as { $_ > 0 }
  subset Character of Str where { .chars == 1 }; # same as { $_.chars == 1 }
                                                 # or as *.chars == 1
#+end_src

# NOTE: made a mistake, wrote .elem here instead of .chars, postcondition caught it!

The names of these should be descriptive enough. The part that would need an
explanation is probably just the one after =where=. What you put there has to be
a callable, and is executed every time the variable constrained with the given
=subset= is used.

About the "callable" part: it has to be a routine that accepts a single
parameter. Raku has quite a few ways of writing anonymous callables, here you
can see two: [[https://docs.raku.org/type/WhateverCode][WhateverCode]] and [[https://docs.raku.org/type/Block][Block]]. The first one forms a block whose single
argument is replaced for the star =*= in the enclosing expression. The other
forms a block with the first positional parameter assigned to a "topic
variable", called =$_=, inside the block (similar to how blocks in Groovy or
Kotlin use =it= as a default block argument name). 

Another bit of syntax: in a method call, if the object (or "invocant" in
Raku-speak) is missing, the method is called on the topic variable. Various
constructs set the topic variable, including =for=, =with=, and =given= keywords.

#+begin_src raku +n :tangle ShowTable.rakumod
  subset MaybeColoredStr where Str | Colored;
  subset ColumnSpec where Iterable | Int | Nil;
#+end_src

Ok, so you remember I told you that =where= needs to be passed a callable?
Actually, no, I lied. Well, simplified. The truth is you can put there anything
that you can use the =~~= "smart-matching" operator[fn:7] on. That operator
works mostly by calling a magic-method called =ACCEPTS= on RHS. Various "things"
implement that method, including - as you probably realized already - callables,
where smart-matching simply calls the routine with LHS operand as an argument.

TODO: the "smart-matching" operator also exists in Ruby, Groovy, and Smalltalk.
There might be implementations for other languages, too.

So what you can put into =where= clause includes everything that works with
=~~=, which is basically anything. For simple values, smart-matching is
analogous to structural comparison (written as ===== normally), but for type
and role (interfaces, mixins) they perform an =.isa= or =.does= check on the LHS
value.

*TL;DR*: =MaybeColoredStr=, when used, will check whether a given value is a
=Str=, =Colored=, or any of their subclasses.

**** Junctions

The last interesting bit of syntax, and an interesting concepts is "junctions".
Junctions are basically lazy conditions that aggregate a bunch of condition
subjects, and are responsible for applying a check to all junctions members and
combining results. You could do the same with collections, but the syntax of
junctions is much nices. Last example on junctions before moving on:

#+begin_src raku
  dd my $ored = (3 | 4 | 5);      # is the same as: (3, 4, 5).any
  # Junction $ored = any(3, 4, 5)
  dd (4 == $ored);
  # any(Bool::False, Bool::True, Bool::False)
  dd (4 == $ored).so;             # reduces to single value in boolen context
  # Bool::True
  dd my $anded = (3 & 4 & 5);     # is the same as: (3, 4, 5).all
  # Junction $anded = all(3, 4, 5)
  dd $anded âˆˆ 1..10;              # âˆˆ mean "is element of"
  # all(True, True, True)
  dd ($anded âˆˆ 1..10).so;         # again, reduces to a single value
  # Bool::True
#+end_src

=dd= is a debug function specific to Rakudo, which prints a value and its type
to stderr (I think?). 

Pay attention to the "is the same as" comments: you'll need them in the next
fragment!

#+begin_src raku +n :tangle ShowTable.rakumod
  subset StrList of Iterable where { .cache.all ~~ MaybeColoredStr };
  subset IntList of Iterable where { .cache.all ~~ Int };
  subset StrTable of Iterable where { .cache.all ~~ StrList };
#+end_src

These checks are *expensive*, and they may have unintended cosequences for some
of the =Iterable= sybtypes (eg. the lazy ones, hence the =.cache=[fn:8] call).
On the other hand, not having to worry about the shape of the data *at all*
within this module is too convenient to give up, and my use case does not
involve large input sizes.

#+begin_src raku +n :tangle ShowTable.rakumod
  enum JustifyType is export <None Left Right Center>;
#+end_src

There are some advantages to the use of enums... and then there's Raku which
eliminates almost all of them... ðŸ™‚ No exhaustiveness checking, no distinct
identity for cases, no parametrization, just a little nicer syntax
for a named subset of literal values. Basically, it's an =enum= you know and
love from C, not a discriminated union you know and love *more* from ML.

And BTW, see this?

#+begin_src raku
  enum JustifyType is export <None Left Right Center>;
  #                            ðŸ‘† 
#+end_src

I wasn't intending on having this as an option, but then discovered that my
first option has a value of 0, which is treated as false in boolean context -
same as =Nil=. That means I'd need to check for definitedness (a way to discern
=Nil= from other falsey values) when using =JustifyType= with optional
arguments! I should probably just explicitly assign values to enums, but adding
=None= that would be 0/False kind-of-sort-of makes sense in this case, too.

*** Helpers for padding strings and lists
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__helpers-for-padding-strings-and-lists
:END:

I have to wonder, didn't NPM and /left-pad/ fiasco[fn:9] teach us all that
having no padding function in a standard library is a bad thing? (Well, among
other things about contemporary programmers' culture, but that's for another
time.) Most languages took it to heart; some examples:

- Python has =str.ljust, str.rjust, and str.center=
- Elixir has =String.pad_leading, String.pad_trailing= (no centering though)
- Nim has =strutils.{alignRight, alignLeft, center}=
- Haxe has =StringTools.{rpad, lpad}=
- Ruby has =String.{center, ljust, rjust}=
- Smalltalk (ST/X) has =CharArray>>{#paddedTo:, #leftPaddedTo:, #centerPaddedTo:}=
- Groovy has ={.padLeft, .padRight, .center}= added to =java.lang.String=

and so on... yet here Raku makes me code this by hand? Even Scala has at least
=String.padTo=! Or maybe I'm supposed to install a package just for this? I'm
still not quite sure what kinds of packages are there.

#+begin_src raku +n :tangle ShowTable.rakumod
  #| Pads given string with a given character up to a limit. Can pad on both
  #| sides.
  our sub str-justify(
      MaybeColoredStr $s,
      Positive $limit,
      JustifyType $type,
      Character $pad = " ",
      --> Str(MaybeColoredStr)
  ) is export(:tests) {
      PRE $s.chars <= $limit;
      POST $_âœ”{ .no-color.chars == $limit } # NOTE: caught the problem with Character

      my $diff := $limit - $s.chars;
      given $type {
          when Left  { $s ~ ($pad x $diff); }
          when Right { ($pad x $diff) ~ $s; }
          when * { warn "Type {$type} not implemented yet!"; $s } # a bug here would be caught by the postcondition, too
      }
  }
#+end_src

**** Module exports

First: we're inside a module and we're defining names. By default, all names are
considered private to the enclosing module (thought they might be visible to whe
nested modules). That means there's no way to access the names declared that way
(with explicit or implicit =my=). As a module's author, you have to decide what
names should be accessible, and _how_.

We've seen it already, there's a =use= statement that allows users to depend on
the external module. However, what happens when that statement is executed is
almost entirely up to the module author. Here are the options and what happens
after =use= depending on your choice:

- use =our= instead of =my= qualifier for a name. This results in the name being
  accessible via Fully Qualified Name, that is,
  =ModuleName::name-of-our-symbol=.
- use =is export= trait on a name. This results in the name being injected
  directly into the current scope. Crucially, a name with this trait, but
  without =our= qualifier, *is not* accessible via FQN. You still can refer to
  the name with a qualified name, but it gets ugly:
  =ModuleName::EXPORT::ALL::exported-my-name=
- use =is export(:group1, :group2)= trait on a name. This is quite an original
  idea: inside a module, there can be any number of inner namespaces. This trait
  puts the name into one or more of them. The namespaces are created if they
  don't yet exist. Then, the user can import only names belonging to a
  particular group, like this: =use ModuleName :group1=.
- any combination of the above, with expected semantics. 

Here are some examples:
#+begin_src raku 
  module ModuleName {
      our sub f1() { say "Called {&?ROUTINE.raku}" }
      sub f2() is export { say "Called {&?ROUTINE.raku}" }
      sub f3() is export(:group1) { say "Called {&?ROUTINE.raku}" }
      our sub f4() is export { say "Called {&?ROUTINE.raku}" }
      sub f5() is export(:ALL, :group2) { say "Called {&?ROUTINE.raku}" }
  }
#+end_src

**** Routine arguments

In Raku, arguments to routines can be constrained with a type, which can be
either a class, a role, or a subset, and also with =where= clauses (same meaning
as with subsets). NOTE: I'm not sure about scoping of identifiers in the =where=
clauses. In =sub f($a, $b, $c where { ... }, $d)=, in the =where= block, is =$d=
visible? Are =$a= and =$b= visible? Need to check.

Arguments can have default values.

**** First routine contracts

Routines can have contracts, too. First, the types and where clauses are routine
pre-conditions. These are checked before entering the routine. They mostly deal
with values of single arguments.

Then, there are explicit pre-conditions, in the form of =PRE= blocks. They
execute after type checks of arguments, but before anything else. They mostly
deal with relations between arguments.

Then, there are post-conditions, in the form of =POST= blocks. They execute
after the return value is known, but before final type check. =POST= blocks set
the return value as a topic variable, and they have access to all the function
arguments, too. 

NOTE: currently, =POST= blocks are executed even if the dispatch to the function
failed, or in other words: one or more arguments didn't meet the required
constrains. The construct =$_âœ”{ ... }= uses a custom operator, =âœ”=, to only call
the post-condition block when the returned value is defined - in the case of
dispatch failure it won't be. See more in [[Utils.rakumod]].

Finally, there's a type check provided by the function signature with either
=-->= arrow inside the argument list, or by adding one of the traits after the
closing paren: =returns(SomeType)= or =of SomeType= (I think, TODO)

**** Coercible types

Variables and arguments can be told to accept types other then the one declared
and attempt to automatically convert the incoming type to the one declared. The
coercion happens by calling a method on the incoming value that has the same
name as the target type. This:

#+begin_src raku
  my Str(Any) $a = 2;
#+end_src

Tells variable =$a= to accept any kind of value that has =.Str= method, which is
then called before performing the assignment.

The same coercion can happen with the return type of a function, where the
return value is coerced to the required type before being returned.

**** Operators used

Raku allows defining custom operators, and also includes a multitude of
operators built-in. They are implemented as variants of one of the few
multi-methods. 

- =~= is string concatenation operator: ="a" ~ "b" eq "ab"= (BTW, =eq= is string
  equality)
- =x= is string repeat operator: ="a" x 5 eq "aaaaa"=
- =*= has a few meanings, but here it's used as an instance of =Whatever= type,
  which will match anything.

=given $obj { when 1 {}; when 2 {}; default {} }= is Raku version of
pattern-matching, but here it works like a simple =switch= statement from C (it
can do more, though).


# BTW: I think the module systems gives WAY too much to the module author. It's
# a module's user that should decide which identifiers they wish to have
# injected into often top-level module scope.

#+begin_src raku +n :tangle ShowTable.rakumod
  sub list-justify(
      Iterable $row,
      Positive $cols,
      Any :$fill = "",
      JustifyType :justify(:$type) = Left,
      --> List
  ) is export(:tests) {
      PRE $row.elems <= $cols; # TODO: description/extended name for the contract, { "jgvjv"; ...} or maybe  #= ?
      POST $_âœ”{ .elems == $cols };  

      return $row if .elems == $cols;
      my $diff := $cols - $row.elems;
      my $fill-list := (1..$diff).map:{ my $ = $fill }; # any other way?
      given $type {
          when Left  { $row âŠ• $fill-list }
          when Right { $fill-list âŠ• $row }
          when * { warn "Type {$type} not implemented yet!"; $row  }
      }
  }
#+end_src

The two routines look very similar, but I'm not convinced DRYing them would be a
good idea. The =list-justify= is more general, and we could reduce =str-justify=
to a simple call to =list-justify=:

#+begin_src raku
  list-justify($s.comb, $limit, $pad).join;
#+end_src

But handling colored text would still need to be done somewhere, and I imagine
using Str-specific functions will be faster than converting back and forth
between Str and List. We could make both justify functions into a single
=multi=, but I don't think it would be any better then currently. Or would it?

To abstract over the kind of a thing we're padding/justifying further we would
need to take a bunch of functions/operators, namely for: getting length of the
thing, multiplying (repeating) the thing, and concatenating two things. It would
be ={.chars}=, =&infix:<~>=, =&infix:<x>=, respectively, for strings. It can be
done, but again, I don't see the reason to. 

Also, first-class functions, especially partially applied ones, are really bad
for performance on MoarVM. As you can read on the [[https://moarvm.com/roadmap.html][Roadmap page]], work on
optimizing this is ongoing:

#+begin_quote
Better optimization around closures

Today's optimizer does a poor job of, and has an inability to inline, first
class functions and closures. Recent work has started to collect the data needed
to do better; optimizations to exploit it are still to come.
#+end_quote

*** Formatting a single cell
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__formatting-a-single-cell
:END:

#+begin_src raku +n :tangle ShowTable.rakumod
  #| Make sure the returned string has exactly $limit characters, clipping or
  #| padding as needed.
  our sub format-cell(
      MaybeColoredStr $text,
      Positive $cell-width,
      JustifyType :justify(:$cell-justify-type) = Left,
      Character :$cell-padding = " ",
      --> Str(MaybeColoredStr)
  ) {
      POST $_âœ”{ .no-color.chars == $cell-width };

      my Int $char-num := $text.chars;
      if $char-num > $cell-width {
          $text.substr(0, $cell-width - 1) ~ "â€¦";
      }
      elsif $char-num < $cell-width && ?$cell-justify-type { 
          str-justify($text, $cell-width, $cell-justify-type, $cell-padding);
      }
      else {
          $text;
      }
  }
#+end_src

"Some people would have paused here and started making jokes about how Raku
can't have a "normal else if"... Whoever you are, please, don't be one of
people like *that*...""

*** Formatting the whole table
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__formatting-the-whole-table
:END:

In this routine, we make sure we're dealing with data of one shape only: a list
of rows of equal length, with each row being a list of strings. 

This assumption is expressed succintly and enforced by simply mentioning
=StrTable= in a type position. This assumption is costly to enforce, but frees
this routine from the need to handle most edge cases. 

There are two things that the =StrTable= contract doesn't enforce, so we check
for them in the first precondition. The =$table= has to be non-empty, and
lengths of each row have to be the same. The latter condition is important,
because it lets us rotate the table with =[Z]= meta-operator (see below) without
worrying about losing elements.


#+begin_src raku +n :tangle ShowTable.rakumod
  #| Create a multi-line string with values from $table aligned into columns.
  #| Passed $table cannot be empty.
  our sub format-table(
      StrTable $table is copy,
      Str :$col-separator = " ",
      Positive :$col-separator-width = 5,
      ColumnSpec :w(:chars(:$col-widths)) = Nil,
      Character :$cell-padding = " ",
      JustifyType :justify(:$cell-justify-type) = Left,
      --> Str
  ) is export {
      PRE $table.elems > 0 && [==] $tableÂ».elems; # NOTE
      PRE ($col-widths ~~ Iterable)âˆ{ $col-widths.elems == $table[0].elems };

      my Str $fill := $col-separator x $col-separator-width;
      my @table = @$table;
      # NOTE: the [Z] @table doesn't work when there's only one row
      my $cols := @table.elems == 1 ?? @table[0].map(*.list) !! [Z] @table;

      for get-col-widths($col-widths, $cols).kv -> $col, $max {
          $cols[$col].=map: { format-cell($_, $max, :$cell-padding) }
      }
      # for @table { .join($fill).comb.raku.say }
      join "\n", (.join($fill) for @table);
  }

  our sub show-table(|args) is export {
      put format-table(|args);
  }
#+end_src

In some Lisps, there's a map-list/apply-map-list idiom[fn:10], which forms a
=zip= function. Raku has both =zip= function and a zip /operator/, =Z=; it has
also the =reduce= (often called =fold= or =fold-left=) function and
/meta-operator/ too, so the apply-map-list is written as essentially reduce-zip,
but with shorthand syntax: =[Z] list-of-lists=. It's a simple way of rotating
the table, from list of rows to a list of columns and vice versa.

*** Helpers for interpreting column widths argument
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__helpers-for-interpreting-column-widths-argument
:END:

TODO: first multi-method

#+begin_src raku +n :tangle ShowTable.rakumod
  multi get-col-widths(Int $width, @cols --> IntList) { $width xx @cols.elems }
  multi get-col-widths(Iterable $widths, @cols --> IntList) { $widths }
  multi get-col-widths($ where ?*.not, @cols --> IntList) { samewith(@cols) }

  multi get-col-widths(@cols where { .all ~~ StrList  } --> IntList) {
      POST $_âœ”{ .elems == @cols.elems };
      my @widths[@cols.elems];
      @widths[$_] = (@cols[$_]Â».chars.max or 1) for @widths.keys;
      @widths
  }
#+end_src

*** Converting lists to tables - main API
:PROPERTIES:
:CUSTOM_ID: code__showtable.rakumod__converting-lists-to-tables---the-user-facing-interface-of-the-module
:END:

#+begin_src raku +n :tangle ShowTable.rakumod
  use Terminal::Width; # TODO: be smarter about cols number/width if not specified

  our sub to-table(StrList $seq, Int :$cols = 5 --> StrTable) is export {
      my $table := $seq.batch($cols)Â».Array.Array;
      $table.tail.=&list-justify($cols);
      $table
  }

  sub make-lorem-table(Int :r(:$rows), Int :$cols, Int :$max = 9 --> StrTable) is export(:tests) {
      to-table :$cols, (Utils::lorem-word($max) xx ($rows Ã— $cols))
  }

  our sub show-list-in-table(
      StrList $seq, :$cols = 6, :$row-padding = " ", *%kwargs
  ) is export {
      $seq ==> to-table(:$cols) ==> show-table(|%kwargs);
  }
#+end_src

** Utils.rakumod
:PROPERTIES:
:CUSTOM_ID: code__utils.rakumod
:END:

#+begin_src raku -n :tangle Utils.rakumod
  use v6.d;

  unit module Utils;

  sub show-section-sep() is export { print "\n" ~ "=" x 10 ~ "\n" x 2; }
  sub show-subsection-sep() is export { print "\n" ~ "-" x 10 ~ "\n\n"; }

  multi sub show-section($enabled, &block) { samewith(&block) if $enabled; }
  multi sub show-section(&block) is export {
      show-section-sep;
      block();
      show-section-sep;
  }

  my @lorem-chars = [ |('a'..'z'), |('A'..'Z'), |('0'..'9') ];

  our sub lorem-word(Int $max = 9, Int $min = 3) is export {
      my $span = $min .. $max;
      @lorem-chars.roll($span.pick).join("")
  }


  our sub bench(Int $rep, &block) {
      my $times = do for ^$rep {
          block();
          now - ENTER now;
      }
      my ($fst, *$rest) = $times;
      say "Calls: $rep / ", $fst, " / ", do .sum / .elems with $rest;
  }


  our sub defined-and(Mu $x, &block) is export {
      return True unless $x.defined;
      block($x);
  }

  multi sub infix:<âœ”>(Mu $x, &block) is export {
      return True unless $x.defined;
      block($x);
  }

  multi sub infix:<âˆ>(Mu $x, &block) is export {
      return True unless $x.so;
      block($x);
  }


  # https://github.com/ajs/perl6-Operator-Listcat/blob/master/lib/Operator/Listcat.pm6
  multi sub infix:<listcat>(@a, @b) is equiv(&infix:<~>) is export { |@a, |@b }
  multi sub infix:<âŠ•>(Iterable $a, Iterable $b) is looser(&infix:<xx>) is export {
      |$a, |$b
  }


  our sub join-paths($base, $other --> IO::Path) is export { "$base/$other".IO }

  our sub list-dir($init where Str | IO::Path --> Seq) is export {
      my IO::Path @subdirs = [$init.IO.absolute.IO];
      gather while @subdirs {
          my $cur = @subdirs.shift(); # say $cur;
          my $seq := $cur.dir.cache;
          my ($, $dirs, $files) =
              take ($cur, $seq.grep(*.d)Â».basename, $seq.grep(*.d.not)Â».basename);
          my &absolutize := { join-paths($cur, $_) }
          @subdirs.prepend: $dirsÂ».&absolutize;
      }
  }

#+end_src

** Colors.rakumod
:PROPERTIES:
:CUSTOM_ID: code__colors.rakumod
:END:

#+begin_src raku -n :tangle Colors.rakumod
  use v6.d;

  use MONKEY; # ðŸ™ˆ - because augmenting existing classes is very bad for
              # performance; which is strange, b/c Smalltalk - see note

  unit module Colors;

  use Terminal::ANSIColor;


  our class Colored is export(:types) {
      has Str $.style;
      has Str $.string handles ("chars");

      method new($str, $style) {
          self.bless(style => $style, string => $str)
      }
      method substr(::?CLASS:D: |args) {
          $!string.=substr(|args);
          self.Str;
      }

      method in-color(Str $!style) {}

      method no-color() {
          $!string
      }

      method Str() { $!string.&colored($!style) }
  }


  augment class Str {
      method in-color(Str:D : Str $c) {
          Colored.new(self, $c)
      }

      method no-color(Str:D:) {
          colorstrip(self)
      }
  }
#+end_src

* Examples of use
:PROPERTIES:
:CUSTOM_ID: examples-of-use
:END:
** Meta.rakumod - introspect classes and object
:PROPERTIES:
:CUSTOM_ID: examples-of-use__meta.rakumod
:END:

#+begin_src raku -n :tangle Meta.rakumod
  use v6.d;

  unit module Meta;

  use Terminal::ANSIColor;

  use Utils;
  use ShowTable;


  my $package-names = (
      "MY", "OUR", "CORE", "GLOBAL", "PROCESS", "CALLER", "CALLERS",
      "DYNAMIC", "OUTER", "OUTERS", "LEXICAL", "UNIT", "SETTING", "PARENT",
      "CLIENT"
  );

  # change my -> our to make all the functions available at once when testing
  module Priv {
      use Utils;

      sub all-caps(Str $s --> Bool()) is export {
          $s.match: / ^(<upper>|<[-&$@_%!]>)+$ /;
      }

      sub show-class-header(Mu \obj) is export {
          say (
              "Class",
              colored(obj.^name, "green"),
              "is:",
              colored(obj.^mro.raku, "yellow"),
              "does:",
              colored((try obj.^roles.raku) || "<ERROR>", "bold")
          ).join(' ');
      }

      sub natural-ordering(Str $a, Str $b) is export {
          my ($caps-a, $caps-b) = (all-caps($a), all-caps($b));
          # dd $caps-a, $caps-b, $a, $b;
          my Order $ret = do {
              when $caps-a  && $caps-b  { $a cmp $b }
              when $caps-a  && !$caps-b { Less }
              when !$caps-a && $caps-b  { More }
              default                   { $a cmp $b }
          }
          # dd $ret;
          $ret
      }

      sub sort-by-name(Iterable $seq) is export {
          $seq.sort({ natural-ordering($^a.name, $^b.name) })
      }


      sub classify-symbols($seq) is export {
          $seq.classify: {
              when all-caps(.name) { 'caps' }
              when .name.match(/^<upper>/) { 'upper' }
              default { 'lower' }
          }
      }
  }

  import Priv;


  # ==============================================================================


  our sub meths(Mu \obj) is export {
      show-section-sep;
      show-class-header(obj);
      print "\n";

      my $rows = sort-by-name(obj.^methods.unique(:as(*.name))).map: {
          (colored(.name, "yellow"), .signature.raku, (try "{.file} : {.line}") || "<BUILT-IN>")
      };
      show-table($rows, :widths(15, 40, 40));
  }


  our sub doc($query, :l(:$lines) = 15) is export {
      my $res = qqx[ rakudoc '$query' ];
      if $res {
          say $res.lines[^$lines].join("\n")
      };
      "";
  }


  our sub cls(Mu \obj) is export {
      my $m = obj.^methods.unique(:as(*.name));
      my %m = classify-symbols($m);
      show-section-sep;
      show-class-header(obj);
      for <caps upper lower> {
          FIRST show-subsection-sep;
          sort-by-name(%m{$_})>>.name ==> show-list-in-table(:5cols) if %m{$_}:exists;
          show-subsection-sep;
      }
  }


  our sub ns($pkg) is export {
      # EXPORT::ALL::.keys
      my $fuck = 3;
      say $pkg.^name;
      # say ::("CALLER")::EXPORT::ALL::.keys;
      # $package-names.map({ "- " ~ (try { $_ ~ " " ~ ::("$_")::.keys.raku } || $_ )})>>.say;
  }

#+end_src

** pkgs.raku - show a list of available packages
:PROPERTIES:
:CUSTOM_ID: examples-of-use__pkgs.raku
:END:

#+begin_src raku -n :tangle pkgs.raku
  use v6.d;

  use JSON::Fast;

  use Colors;
  use ShowTable;
  use Utils;


  sub dt(Str $s --> Str) {
      with $s.DateTime {
          (.year, "-", .month.fmt('%02d'), "-", .day.fmt('%02d') ).join
      }
  }

  show-section 1, {
      my constant $fields := <name updated eco likes desc>;
      my constant $widths := [25,  10,     5,  3,    60];

      my @table = [];

      for "raku.pkgs".IO.lines -> $line {
          my $rows := $line.&from-json()>>.{ $fields };
          next unless $rows;
          my $cols := [Z] $rows;
          $cols[1].=map(&dt);     # Why is it working? What made $cols mutable?
          $rows := [Z] $cols;
          @table.append($rows);
      }
      @table.=squish(as => { .[0].lc });
      @table.=grep({ (.[0] | .[4]) ~~ rx:i/term/ });
      dd @table;
      show-table(@table, :col-widths($widths));
  }
#+end_src

* Other scripts
:PROPERTIES:
:CUSTOM_ID: other-scripts
:END:
** watch.raku - watch files for changes
Re-runs a command if one of the watched files changes.

#+begin_src raku -n
  use v6.d;

  use Utils;
  use Colors;
  use ShowTable;

  constant Change = IO::Notification::Change;

  constant $command = "raku -Iraku raku/run.raku";


  sub re-run(Change $change) {
      my $path := $change.path;
      put "$path changed, running command:\n\t$command";
      my $status = shell($command).exitcode;
      my $color = $status ?? "red" !! "green";
      put "\n==========\n".indent(4).in-color($color);
      my $elapsed = now - ENTER now;
      put "Elapsed: $elapsed".indent(4).in-color($color);
      if $status == 0 {  qqx[ noti -m "$elapsed" -t "OK" ];    }
      else            {  qqx[ noti -m "$elapsed" -t "ERROR" ]; }
  }

  sub MAIN(Str $base) {
      my @files = dir($base).grep(/ '.raku'('mod')? $/).grep(none /watch/);
      say "Watching: "; @filesÂ».absolute.map(*.indent(4).say); say "";
      loop {
          my $supply = @filesÂ».watch.reduce({ $^a.merge($^b) });
          react {
              whenever $supply { re-run($_); done }
              # ie. either got Ctrl+C or this file changed
              whenever signal(SIGINT) | $?FILE.IO.watch { exit }
          }
          $supply = Nil;
      }
  }
#+end_src

* COMMENT ...
:PROPERTIES:
:CUSTOM_ID: ...
:END:

** fragments
:PROPERTIES:
:CUSTOM_ID: ...__fragments
:END:

# my constant Change = IO::Notification::Change;
# apparently, selective import is something that needs to be delegated to the
# ecosystem. There are some modules available, but for the simple case of
# shortening package-qualified names this construct suffices. BTW, the defaults
# for the module system are really bad in Raku. Well, better than Ruby, but
# still.


interested in the [[https://raku.org][Raku]] programming language. I even have a proper use-case this
time! Put simply: I want a shell-script replacement that is much safer to use
than BASH, but also more succint than Python. Another thing: I'd prefer a
general-purpose language, thank you for the suggestion, but no Elvish, Murex,
Oil, etc. Moving on:


So it started from the REPL. You see, you can check what methods has any given
object if you invoke a metaclass method called ~methods~. This is the same
approach as in Smalltalk/X:

#+begin_src smalltalk
  2 class getMethodDictionary keys.
  "OrderedCollection(#'*' #'+' #'-' #'/' #'//' #'\\' #abs #negated #quo: #bitAnd: #bitClear: #bitCount #bitInvert ....etc)"
#+end_src

in Raku this is written:

#+begin_src raku
  2.^methods
#+end_src

I mean, something about ~^~ character and "higher level", meta-programming? It's
just basic introspection though... 

In any case, the problem is in how the methods returned are represented, and
displayed. By default it looks like this:

#+begin_src text
  (new Capture Int sign Num Rat FatRat abs Bridge sqrt base polymod expmod is-prime floor ceiling round lsb msb narrow Range conj rand sin asin cos acos tan atan atan2 sec asec cosec acosec cotan acotan sinh asinh cosh acosh tanh atanh sech asech cosech acosech cotanh acotanh unpolar cis Complex log exp truncate isNaN log2 log10 roots succ pred WHICH ACCEPTS raku Bool Str Real Numeric gist DUMP BUILDALL chr unimatch uniname uniprop unival)
#+end_src

and, coupled with acute lack of screen real-estate, would be presented like
this:


Unnecessary addendum: you know when was the last time I've seen a REPL this
pretty? When working with FORTH. Really:


Hopefuly your shell would have wrapped the line for you, but that doesn't help
with readability much. It's possible to print each method in its own line
easily, but then there's too much space wasted, and you have to scroll to see
the beginning of the list, which is also less convenient then it could be.

So, to make the introspection a little more helpful, and for science of course!,
I decided to write a module for printing tables in a terminal. There are some
similar packages on https://raku.land, but neither one is exactly what I want,
and anyway, at that point I didn't think such a thing would be package-worthy on
its own. 

* Footnotes

[fn:14] link
 
[fn:13] link 

[fn:12] See [[https://raku.land/github:thundergnat/Terminal::Boxer][Terminal::Boxer]] or [[https://raku.land/github:ab5tract/Terminal::Print][Terminal::Print]] or [[https://raku.land/?q=table][any of the other packages]].

[fn:11] As implemented in Racket, which is a bit different than the original
Eiffel implementation. This is why I write about "contracts-based" programming
instead of the more specific [[https://en.wikipedia.org/wiki/Design_by_contract][Design by Contract]] term.

[fn:1] Though methodology there is a bit questionable, at best. Plus, it's from
2013, and many languages didn't make it onto a list, and there are multiple
languages that faded into (even more) obscurity since then.

[fn:2] CoffeeScript was in top 5 languages in the study, and LS is even more
succint than Coffee.

[fn:3] http://literateprogramming.com/ and
https://en.wikipedia.org/wiki/Literate_programming

[fn:4] I think these are now recommended, there seem to be a few other
extensions, either used for specific things like tests (with =.t=), or
deprecated ones based on previous name of the language, eg. =.p6=.

[fn:5] Annual festival of light in Hinduism, happening for a few days in October
and November... apparently.

[fn:6] Apparently, a person responsible for writing syntax highlighting died
before being able to finish.

[fn:7] [[https://docs.raku.org/routine/~~]]

[fn:8] https://docs.raku.org/routine/cache#(Any)_method_cache

[fn:9] If you need refresher - I needed - here's the first googled article:
https://www.davidhaney.io/npm-left-pad-have-we-forgotten-how-to-program/

[fn:10] In Racket: =(apply map list '((a b) (c d))) ;=> '((a c) (b d))=

# Local Variables:                                                 #
# eval: (add-hook 'after-save-hook 'my-upload-raku-writeup nil t)  #
# eval: (add-hook 'after-save-hook 'org-html-export-to-html nil t) #
# eval: (add-hook 'after-save-hook 'org-babel-tangle nil t)        #
# End:                                                             #
